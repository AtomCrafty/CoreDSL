/*
 * generated by Xtext 2.10.0
 */
package com.minres.coredsl.tests

import com.google.inject.Inject
import com.minres.coredsl.coreDsl.BoolConstant
import com.minres.coredsl.coreDsl.FloatConstant
import com.minres.coredsl.coreDsl.IntegerConstant
import com.minres.coredsl.tests.util.TestHelper
import org.eclipse.emf.ecore.EObject
import org.eclipse.xtext.testing.InjectWith
import org.eclipse.xtext.testing.extensions.InjectionExtension
import org.eclipse.xtext.testing.validation.ValidationTestHelper
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.^extension.ExtendWith

import static org.junit.jupiter.api.Assertions.assertEquals
import static org.junit.jupiter.api.Assertions.assertFalse
import static org.junit.jupiter.api.Assertions.assertTrue

@ExtendWith(InjectionExtension)
@InjectWith(CoreDslInjectorProvider)
class CoreDslTerminalsTest {

	@Inject extension TestHelper helper
	@Inject ValidationTestHelper validator

	def assertNoIssues(EObject obj) {
		val issues = validator.validate(obj)
		assertTrue(issues.isEmpty())
	}

	def assertIssues(EObject obj) {
		val issues = validator.validate(obj)
		assertFalse(issues.isEmpty())
	}

	@Test
	def void parseIntLiterals() {
		val literals = #[
			"42",
			"0x2a",
			"0x2A",
			"052",
			"0b101010",
			"6'd42",
			"6'h2a",
			"6'h2A",
			"6'o52",
			"6'b101010"
		]

		for (literal : literals) {
			val constant = literal.parseAsConstant() as IntegerConstant
			assertNoIssues(constant)
			assertEquals(42, constant.value.intValue)
		}
	}

	@Test
	def void parseFloatLiterals() {
		val piLiterals = #[
			"3.14",
			"0.314e1",
			"0.0314e+2",
			"3140.e-3",
			"3.14f",
			"3.14F",
			"3.14l",
			"3.14L"
		]
		
		for(pi : piLiterals) {
			val parsed = pi.parseAsConstant()
			assertTrue(parsed instanceof FloatConstant)
			
			val value = (parsed as FloatConstant).value.doubleValue
			assertTrue(Math.abs(value - 3.14) < 1e-6)
		}
		
		val zero = "0.0".parseAsConstant()
		val one = "1.0".parseAsConstant()
		
		assertTrue(zero instanceof FloatConstant)
		assertTrue(one instanceof FloatConstant)
		
		assertTrue(0.0 == (zero as FloatConstant).value.doubleValue)
		assertTrue(1.0 == (one as FloatConstant).value.doubleValue)
	}

	@Test
	def void parseBoolLiterals() {
		val t = "true".parseAsConstant()
		val f = "false".parseAsConstant() 
		
		assertTrue(t instanceof BoolConstant)
		assertTrue(f instanceof BoolConstant)
		
		assertTrue((t as BoolConstant).value)
		assertFalse((f as BoolConstant).value)
	}

	//@Test
	// TODO: Currently, this only checks whether the syntax is accepted. No handling of encoding and escape sequences is done.
	def void parseCharLiterals() {
		val content = '''
			char c;
			c = 'a';
			c = '9';
			c = '"';
			c = '\'';
			c = '\\';
			c = L'x';
			c = u'x';
			c = U'x';
		'''.parseAsBlock()
		validator.assertNoErrors(content)
	}

	//@Test
	// TODO: Currently, this only checks whether the syntax is accepted. No handling of encoding and escape sequences is done.
	def void parseStringLiterals() {
		val content = '''
			char *str;
			str = "hello world 1";
			str = u8"hello world 2";
			str = u"hello world 3";
			str = U"hello world 4";
			str = L"hello world 5";
		'''.parseAsBlock()
		validator.assertNoErrors(content)
	}

	@Test
	def void parseSingleCharIdentifiers() {
		// this test is here because the encoding prefixes for char- and string literals may clobber normal identifiers
		var alphabet = "abcdefghijklmnopqrstuvwxyz"
		alphabet += alphabet.toUpperCase
		for (var i = 0; i < alphabet.length; i++) {
			val c = alphabet.charAt(i);
			val content = '''int «c»;'''.parseAsBlock()
			val issues = validator.validate(content)
			if (! issues.isEmpty) {
				println("Problematic identifier: " + c)
				for (issue : issues)
					println(issue)
			}
			validator.assertNoErrors(content)
		}
	}
}
