/*
 * generated by Xtext 2.10.0
 */
package com.minres.coredsl.tests

import com.google.inject.Inject
import com.minres.coredsl.coreDsl.AssignmentExpression
import com.minres.coredsl.coreDsl.DirectDeclarator
import com.minres.coredsl.coreDsl.ExpressionStatement
import com.minres.coredsl.coreDsl.FloatConstant
import com.minres.coredsl.coreDsl.IntegerConstant
import com.minres.coredsl.coreDsl.PrimaryExpression
import org.eclipse.xtext.testing.InjectWith
import org.eclipse.xtext.testing.extensions.InjectionExtension
import org.eclipse.xtext.testing.validation.ValidationTestHelper
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.^extension.ExtendWith

import static org.junit.jupiter.api.Assertions.assertEquals
import static org.junit.jupiter.api.Assertions.assertFalse
import static org.junit.jupiter.api.Assertions.assertTrue
import com.minres.coredsl.tests.util.TestHelper
import org.eclipse.emf.ecore.EObject

@ExtendWith(InjectionExtension)
@InjectWith(CoreDslInjectorProvider)
class CoreDslTerminalsTest {

	@Inject extension TestHelper helper
	@Inject ValidationTestHelper validator

	def assertNoIssues(EObject obj) {
		val issues = validator.validate(obj)
		assertTrue(issues.isEmpty())
	}

	def assertIssues(EObject obj) {
		val issues = validator.validate(obj)
		assertFalse(issues.isEmpty())
	}

	@Test
	def void parseIntLiterals() {
		val literals = #[
			"42",
			"0x2a",
			"0x2A",
			"052",
			"0b101010",
			"6'd42",
			"6'h2a",
			"6'h2A",
			"6'o52",
			"6'b101010"
		]

		for (literal : literals) {
			val constant = literal.parseAsConstant() as IntegerConstant
			assertNoIssues(constant)
			assertEquals(42, constant.value.intValue)
		}
	}

	@Test
	def void parseIntLiteralSuffixes() {
		val validLiterals = #[
			"42u",
			"42U",
			"42l",
			"42L",
			"42ul",
			"42Ul",
			"42uL",
			"42UL"
		]

		for (literal : validLiterals) {
			val constant = literal.parseAsConstant() as IntegerConstant
			assertNoIssues(constant)
			assertEquals(42, constant.value.intValue)
		}

		// Verilog syntax cannot have the suffix
		assertIssues("6'd42u".parseAsExpression())
		assertIssues("6'd42ul".parseAsExpression())

		// Invalid suffixes
		assertIssues("42uu".parseAsExpression())
		assertIssues("42ulu".parseAsExpression())
		assertIssues("42lL".parseAsExpression())
	}

	@Test
	def void parseFloatLiterals() {
		val compound = '''
			double d, d1, d0;
			float f;
			long double ld;
			
			d = 3.14;
			d = 0.314e1;
			d = 0.0314e+2;
			d = 3140.e-3;
			d1 = 1.;
			d1 = 1.e0;
			d0 = 0.0;
			
			f = 3.14f;
			f = 3.14F;
			ld = 3.14l;
			ld = 3.14L;
		'''.parseAsBlock()
		validator.assertNoErrors(compound)

		for (el : compound.items.subList(3, compound.items.size())) {
			if (el instanceof ExpressionStatement) {
				val expr = el.expr.expressions.get(0) as AssignmentExpression
				val lhsName = ((expr.left as PrimaryExpression).ref as DirectDeclarator).name;
				val rhs = (expr.assignments.get(0).right as PrimaryExpression).constant as FloatConstant
				val floatValue = rhs.value.doubleValue
				if (lhsName == "d" || lhsName == "f" || lhsName == "ld")
					assertTrue(Math.abs(floatValue - 3.14) < 1e-6)
				else if (lhsName == "d1")
					assertTrue(floatValue == 1.0)
				else
					assertTrue(floatValue == 0.0)
			}
		}
	}

	@Test
	def void parseBoolLiterals() {
		val content = '''
			bool b;
			b = true;
			b = false;
		'''.parseAsBlock()
		validator.assertNoErrors(content)
	}

	@Test
	def void parseCharLiterals() {
		val content = '''
			char c;
			c = 'a';
			c = '9';
			c = '"';
			c = '\'';
			c = '\\';
			c = L'x';
			c = u'x';
			c = U'x';
		'''.parseAsBlock()
		validator.assertNoErrors(content)

	// TODO: Currently, this only checks whether the syntax is accepted. No handling of encoding and escape sequences is done.
	}

	@Test
	def void parseStringLiterals() {
		val content = '''
			char *str;
			str = "hello world 1";
			str = u8"hello world 2";
			str = u"hello world 3";
			str = U"hello world 4";
			str = L"hello world 5";
		'''.parseAsBlock()
		validator.assertNoErrors(content)

	// TODO: Currently, this only checks whether the syntax is accepted. No handling of encoding and escape sequences is done.
	}

	@Test
	def void parseSingleCharIdentifiers() {
		// this test is here because the encoding prefixes for char- and string literals may clobber normal identifiers
		var alphabet = "abcdefghijklmnopqrstuvwxyz"
		alphabet += alphabet.toUpperCase
		for (var i = 0; i < alphabet.length; i++) {
			val c = alphabet.charAt(i);
			val content = '''int «c»;'''.parseAsBlock()
			val issues = validator.validate(content)
			if (! issues.isEmpty) {
				println("Problematic identifier: " + c)
				for (issue : issues)
					println(issue)
			}
			validator.assertNoErrors(content)
		}
	}
}
