/*
 * generated by Xtext 2.10.0
 */
package com.minres.coredsl.tests

import com.google.inject.Inject
import com.minres.coredsl.coreDsl.CoreDef
import com.minres.coredsl.coreDsl.DescriptionContent
import org.eclipse.emf.ecore.util.EcoreUtil
import org.eclipse.xtext.generator.GeneratorContext
import org.eclipse.xtext.generator.IGenerator2
import org.eclipse.xtext.generator.InMemoryFileSystemAccess
import org.eclipse.xtext.testing.InjectWith
import org.eclipse.xtext.testing.XtextRunner
import org.eclipse.xtext.testing.util.ParseHelper
import org.eclipse.xtext.util.CancelIndicator
import org.junit.Test
import org.junit.runner.RunWith

import static org.junit.Assert.*

@RunWith(XtextRunner)
@InjectWith(CoreDslInjectorProvider)
class CoreDslGenerationTest{

    @Inject IGenerator2 underTest
    
    @Inject ParseHelper<DescriptionContent> parseHelper

    val isa_rv32i = '''
            Core RV32I {
                constants {
                    XLEN:=32;
                }
                address_spaces {
                    MEM[8], CSR[32]
                }            
                registers { 
                    [31:0]   X[XLEN],
                            PC[XLEN](is_pc),
                            mepc[XLEN],
                            mtvec[XLEN]
                            
                } 
                instructions { 
                    ADDI {
                        encoding: imm[11:0] | rs1[4:0] | b000 | rd[4:0] | b0010011;
                        if(rd!=0) X[rd] <= X[rs1] + sext(imm, XLEN);
                    }
                    SLTI {
                        encoding: imm[11:0] | rs1[4:0] | b010 | rd[4:0] | b0010011;
                        if(rd!=0) X[rd] <= choose(X[rs1]s < sext(imm, XLEN), 1, 0);
                    }
                    SLTIU {
                        encoding: imm[11:0] | rs1[4:0] | b011 | rd[4:0] | b0010011;
                        if(rd!=0) X[rd] <= choose(X[rs1] < zext(imm, XLEN), 1, 0);
                    }
                    SW {
                        encoding: imm[11:5] | rs2[4:0] | rs1[4:0] | b010 | imm[4:0] | b0100011;
                        val offs[32] <= X[rs1]s + sext(imm, XLEN);
                        MEM[offs] <= X[rs2];
                    }
                    JAL(no_cont) {
                            encoding: imm[20:20]s | imm[10:1]s | imm[11:11]s | imm[19:12]s | rd[4:0] | b1101111;
                            if(rd!=0) X[rd] <= PC+4;
                            PC<=PC+sext(imm);
                    }
                    
                }
            }
        '''
        
    @Test
    def void generateCpp() {
    	val content = parseHelper.parse(isa_rv32i)
        assertNotNull(content)
    	assertEquals(1, content.definitions.size)
        val resource = content.eResource
        EcoreUtil.resolveAll(resource);
        assertEquals(0, resource.errors.size)
        assertEquals(0, resource.warnings.size)
        val fsa = new InMemoryFileSystemAccess()
        underTest.doGenerate(content.eResource, fsa, new GeneratorContext => [
			cancelIndicator = CancelIndicator.NullImpl
		])
        println(fsa.textFiles)
        assertEquals(3,fsa.textFiles.size)
        assertTrue(fsa.textFiles.containsKey("vm-out"+"sim-rv32i_instr.cc"))
//        assertEquals(
//            '''
//            public class Alice {
//                 
//            }
//            '''.toString, fsa.textFiles.get(IFileSystemAccess::DEFAULT_OUTPUT+"Alice.java").toString
//        )
        assertTrue(fsa.textFiles.containsKey("incl-out"+"rv32i.h"))
//        assertEquals(
//            '''
//            public class Bob {
//                 
//            }
//            '''.toString, fsa.textFiles.get(IFileSystemAccess::DEFAULT_OUTPUT+"Bob.java").toString)         
    }
    @Test
    def void expandCppFile() {
        val content = parseHelper.parse(isa_rv32i)
        assertNotNull(content)
        val resource = content.eResource
        EcoreUtil.resolveAll(resource);
        assertEquals(0, resource.errors.size)
        assertEquals(0, resource.warnings.size)
        val CoreDef model = content.definitions.get(0) as CoreDef
        assertNotNull(model)
        val fsa = new InMemoryFileSystemAccess()
        val quote1 = '«'
        val quote2 = '»'
        fsa.generateFile("vm_" + model.name.toLowerCase + ".in.cpp", "vm-out", '''
        	/* «quote1»start generated code«quote2» */
        	InstructionDesriptor instr_descr[0] = {};
        	/* «quote1»end generated code«quote2»  */
        ''')
        underTest.doGenerate(model.eResource, fsa, new GeneratorContext => [
			cancelIndicator = CancelIndicator.NullImpl
		])
        println(fsa.textFiles)
        assertEquals(4,fsa.textFiles.size)
        assertTrue(fsa.textFiles.containsKey("vm-out"+"vm_rv32i.cpp"))
//        assertEquals(
//            '''
//            public class Alice {
//                 
//            }
//            '''.toString, fsa.textFiles.get(IFileSystemAccess::DEFAULT_OUTPUT+"Alice.java").toString
//        )
        assertTrue(fsa.textFiles.containsKey("incl-out"+"rv32i.h"))
//        assertEquals(
//            '''
//            public class Bob {
//                 
//            }
//            '''.toString, fsa.textFiles.get(IFileSystemAccess::DEFAULT_OUTPUT+"Bob.java").toString)         
    }
 }
