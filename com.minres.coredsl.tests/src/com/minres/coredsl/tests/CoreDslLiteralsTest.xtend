/*
 * generated by Xtext 2.10.0
 */
package com.minres.coredsl.tests

import com.google.inject.Inject
import com.minres.coredsl.coreDsl.AssignmentExpression
import com.minres.coredsl.coreDsl.CompoundStatement
import com.minres.coredsl.coreDsl.DescriptionContent
import com.minres.coredsl.coreDsl.ExpressionStatement
import com.minres.coredsl.coreDsl.InstructionSet
import com.minres.coredsl.coreDsl.IntegerConstant
import com.minres.coredsl.coreDsl.PrimaryExpression
import org.eclipse.xtext.testing.InjectWith
import org.eclipse.xtext.testing.XtextRunner
import org.eclipse.xtext.testing.util.ParseHelper
import org.eclipse.xtext.testing.validation.ValidationTestHelper
import org.junit.Test
import org.junit.runner.RunWith

import static org.junit.Assert.assertEquals
import static org.junit.Assert.assertFalse

@RunWith(XtextRunner)
@InjectWith(CoreDslInjectorProvider)
class CoreDslLiteralsTest {

    @Inject extension ParseHelper<DescriptionContent> parseHelper

    @Inject ValidationTestHelper validator

    def CharSequence addBehaviorContext(CharSequence str)'''
        InstructionSet TestISA {
            registers { 
                [[is_pc]] int PC ;
                int Xreg[32];
                float Freg[32];
            }
            instructions {
            	FOO {
            		encoding: b0000000 :: rs2[4:0] :: rs1[4:0] :: b000 :: rd[4:0] :: b1111011;  
            		args_disass: "{name(rd)}, {name(rs1)}, {name(rs2)}";
            		behavior: {
            			«str»
            		}
            	}
            }
        }
    '''
    
    def assertIssues(CharSequence str) {
    	val content = addBehaviorContext(str).parse
    	val issues = validator.validate(content)
		assertFalse(issues.isEmpty())
    }
    
    @Test
    def void parseIntLiterals() {
    	val content = addBehaviorContext('''
			// C syntax
			unsigned c;
			c = 42;
			c = 0x2A;
			c = 052;
			c = 0b101010;
			
			// Verilog syntax
			unsigned<6> v;
			v = 6'd42;
			v = 6'h2a;
			v = 6'o52;
			v = 6'b101010;
    	''').parse
    	validator.assertNoErrors(content)
    	
    	val compound = ((content.definitions.get(0) as InstructionSet).instr.get(0).behavior as CompoundStatement)
		for (el : compound.items) {
			if (el instanceof ExpressionStatement) {
				val expr = (el as ExpressionStatement).expr as AssignmentExpression
				val rhs = (expr.rights.get(0) as PrimaryExpression).constant as IntegerConstant
				assertEquals(rhs.value.intValue, 42)
			}
		}
    }
    
    @Test
    def void parseIntLiteralSuffixes() {
    	val content = addBehaviorContext('''
			unsigned u32;
			unsigned long u64;
			unsigned long long u128;
			long i64;
			long long i128;
			u32 = 42u;
			u32 = 42U;
			
			i64 = 42l;
			i64 = 42L;
			i128 = 42ll;
			i128 = 42LL;
			
			u64 = 42ul;
			u128 = 42ull;
			// u64 = 42lu;  // currently not supported
			// u128 = 42llu; // ditto
    	''').parse
    	validator.assertNoErrors(content)
    	
    	val compound = ((content.definitions.get(0) as InstructionSet).instr.get(0).behavior as CompoundStatement)
		for (el : compound.items.subList(3, compound.items.size())) {
			if (el instanceof ExpressionStatement) {
				val expr = (el as ExpressionStatement).expr as AssignmentExpression
				val lhsName = (expr.left as PrimaryExpression).ref.name;
				val rhs = (expr.rights.get(0) as PrimaryExpression).constant as IntegerConstant
				val intValue = rhs.value.intValue
				assertEquals(intValue, 42)
				// FIXME: cannot check size and signedness, because the BigIntegerWithRadix class is not accessible here -- why?
			}
		}
		
		assertIssues("int i = 6'd42u;") // Verilog syntax cannot have the suffix
		assertIssues("int i = 6'd42ul;")
		assertIssues("int i = 42uu;")
		assertIssues("int i = 42lul;")
		assertIssues("int i = 42ulu;")
//		assertIssues("int i = 42lL;") // TODO: The INTEGERValueConverter currently does not handle this case -- does it matter?
		assertIssues("int i = 42lll;")
    }
    
	@Test
	def void testSingleCharIdentifiers() {
		var alphabet = "abcdefghijklmnopqrstuvwxyz"
		alphabet += alphabet.toUpperCase
		for (var i = 0; i < alphabet.length; i++) {
			val c = alphabet.charAt(i);
			val content = addBehaviorContext('''int «c»;''').parse
			val issues = validator.validate(content)
			if (! issues.isEmpty) {
				println("Problematic identifier: " + c)
				for (issue : issues)
					println(issue)
			}
			validator.assertNoErrors(content)
		}
	}
}
