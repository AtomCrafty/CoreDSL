/*
 * generated by Xtext 2.10.0
 */
package com.minres.coredsl.tests

import com.google.inject.Inject
import com.minres.coredsl.coreDsl.DescriptionContent
import org.eclipse.xtext.testing.InjectWith
import org.eclipse.xtext.testing.XtextRunner
import org.eclipse.xtext.testing.util.ParseHelper
import org.eclipse.xtext.testing.validation.ValidationTestHelper
import org.junit.Test
import org.junit.runner.RunWith
import static org.junit.Assert.assertTrue
import static org.junit.Assert.assertFalse
import java.io.FileReader
import static extension com.google.common.io.CharStreams.*

@RunWith(XtextRunner)
@InjectWith(CoreDslInjectorProvider)
class CoreDslScopingTest {

    @Inject extension ParseHelper<DescriptionContent> parseHelper

    @Inject ValidationTestHelper validator

    @Test
    def void useBeforeDeclaration() {
        val content = '''
        InstructionSet TestISA {
            instructions {
                Inst1 {
                    encoding: b0000000 :: rs2[4:0] :: rs1[4:0] :: b000 :: rd[4:0] :: b0000000;  
                    args_disass: "{name(rd)}, {name(rs1)}, {name(rs2)}";
                    behavior: {
                        x = 0;
                        int x;
                    }
                }
            }
        }
        '''.parse
        val issues = validator.validate(content)
        assertFalse(issues.isEmpty())
    }
    
    @Test
    def void declarationBeforeUse() {
        val content = '''
        InstructionSet TestISA {
            instructions {
                Inst1 {
                    encoding: b0000000 :: rs2[4:0] :: rs1[4:0] :: b000 :: rd[4:0] :: b0000000;  
                    args_disass: "{name(rd)}, {name(rs1)}, {name(rs2)}";
                    behavior: {
                        int x;
                        x = 0;
                    }
                }
            }
        }
        '''.parse
        val issues = validator.validate(content)
        assertTrue(issues.isEmpty())
    }
    
    @Test
    def void useBeforeDeclarationNested() {
        val content = '''
        InstructionSet TestISA {
            instructions {
                Inst1 {
                    encoding: b0000000 :: rs2[4:0] :: rs1[4:0] :: b000 :: rd[4:0] :: b0000000;  
                    args_disass: "{name(rd)}, {name(rs1)}, {name(rs2)}";
                    behavior: {
                        {
                            x = 0;
                        }
                        int x;
                    }
                }
            }
        }
        '''.parse
        val issues = validator.validate(content)
        assertFalse(issues.isEmpty())
    }
    
    @Test
    def void declarationBeforeUseNested() {
        val content = '''
        InstructionSet TestISA {
            instructions {
                Inst1 {
                    encoding: b0000000 :: rs2[4:0] :: rs1[4:0] :: b000 :: rd[4:0] :: b0000000;  
                    args_disass: "{name(rd)}, {name(rs1)}, {name(rs2)}";
                    behavior: {
                        int x;
                        {
                            x = 0;
                        }
                    }
                }
            }
        }
        '''.parse
        val issues = validator.validate(content)
        assertTrue(issues.isEmpty())
    }
    
    @Test
    def void globalScope() {
        val content = '''
            InstructionSet TestISA {
            constants {
                int CCC = 42;
            }
            registers {
                unsigned X[32];
            }

            functions {
                int foo(int arg) {
                    return arg;
                }
            }

            instructions {
                Inst1 {
                    encoding: b0000000 :: rs2[4:0] :: rs1[4:0] :: b000 :: rd[4:0] :: b0000000;  
                    args_disass: "{name(rd)}, {name(rs1)}, {name(rs2)}";
                    behavior: {
                        X[rd] = X[rs1] + X[rs2] + foo(CCC);
                    }
                }
            }
        }
        '''.parse
        val issues = validator.validate(content)
        assertTrue(issues.isEmpty())
    }
    
    @Test
    def void globalScopeExtended() {
        val content = '''
        InstructionSet TestISA {
            constants {
                int CCC = 42;
            }
            registers {
                unsigned X[32];
            }

            functions {
                int foo(int arg) {
                    return arg;
                }
            }
        }
        
        InstructionSet TestISA2 extends TestISA {
            instructions {
                Inst1 {
                    encoding: b0000000 :: rs2[4:0] :: rs1[4:0] :: b000 :: rd[4:0] :: b0000000;  
                    args_disass: "{name(rd)}, {name(rs1)}, {name(rs2)}";
                    behavior: {
                        X[rd] = X[rs1] + X[rs2] + foo(CCC);
                    }
                }
            }
        }
        '''.parse
        val issues = validator.validate(content)
        assertTrue(issues.isEmpty())
    }
    
    @Test
    def void globalScopeFromFile() {
        val content = '''
        import "inputs/isa_1.core_desc"
        
        InstructionSet TestISA2 extends RV32I {
            instructions {
                Inst1 {
                    encoding: b0000000 :: rs2[4:0] :: rs1[4:0] :: b000 :: rd[4:0] :: b0000000;  
                    args_disass: "{name(rd)}, {name(rs1)}, {name(rs2)}";
                    behavior: {
                        X[rd] = X[rs1] + X[rs2] + XLEN;
                    }
                }
            }
        }
        '''.parse
        val issues = validator.validate(content)
        assertTrue(issues.isEmpty())
    }
    
    @Test
    def void firExample() {
        val content = new FileReader('inputs/fir.core_desc').readLines.join('\n').parse
        validator.assertNoErrors(content)
    }
    
    @Test
    def void structMembersDirect() {
        val content = '''
        InstructionSet TestISA {
            registers {
                struct {
                    unsigned x, y;
                } point;
            }
            
            instructions {
                Inst1 {
                    encoding: b0000000 :: rs2[4:0] :: rs1[4:0] :: b000 :: rd[4:0] :: b0000000;  
                    behavior: {
                        unsigned sum = point.x + point.y;
                    }
                }
            }
        }
        '''.parse
        val issues = validator.validate(content)
        assertTrue(issues.isEmpty())
    }

    @Test
    def void structMembersIndirect() {
        val content = '''
        InstructionSet TestISA {
            registers {
                struct point_s {
                    unsigned x, y;
                };
            }
            
            instructions {
                Inst1 {
                    encoding: b0000000 :: rs2[4:0] :: rs1[4:0] :: b000 :: rd[4:0] :: b0000000;  
                    behavior: {
                        struct point_s  point;
                        unsigned sum = point.x + point.y;
                    }
                }
            }
        }
        '''.parse
        val issues = validator.validate(content)
        assertTrue(issues.isEmpty())
    }
    
    @Test
    def void structMembersDirectSub() {
        val content = '''
        InstructionSet TestISA {
            constants {
                unsigned N_REGS = 4;
            }
            registers {
                struct {
                    float real;
                    float imag;
                } complex[N_REGS];
            }
            
            instructions {
                Inst1 {
                    encoding: b0000000 :: rs2[4:0] :: rs1[4:0] :: b000 :: rd[4:0] :: b0000000;  
                    args_disass: "{name(rd)}, {name(rs1)}, {name(rs2)}";
                    behavior: {
                        float x = complex[1].real * complex[1].imag;
                    }
                }
            }
        }
        '''.parse
        val issues = validator.validate(content)
        assertTrue(issues.isEmpty())
    }
    
    @Test
    def void structMembersIndirectSub() {
        val content = '''
        InstructionSet TestISA {
            constants {
                unsigned N_REGS = 4;
            }
            registers {
                struct point_s {
                    unsigned x, y;
                };
            }
            
            instructions {
                Inst1 {
                    encoding: b0000000 :: rs2[4:0] :: rs1[4:0] :: b000 :: rd[4:0] :: b0000000;  
                    behavior: {
                        struct point_s  point[N_REGS];
                        unsigned sum = point[0].x + point[0].y;
                    }
                }
            }
        }
        '''.parse
        val issues = validator.validate(content)
        assertTrue(issues.isEmpty())
    }
    
    @Test
    def void structMembersDirectNested() {
        val content = '''
        InstructionSet TestISA {
            registers {
                struct rect_s {
                    struct origin_s {
                        unsigned x, y;
                    } origin;
                    struct size_s {
                        unsigned x, y;
                    } size;
                } rect;
            }
            
            instructions {
                Inst1 {
                    encoding: b0000000 :: rs2[4:0] :: rs1[4:0] :: b000 :: rd[4:0] :: b0000000;  
                    behavior: {
                        unsigned sum = rect.origin.x;// + rect.size.x;
                    }
                }
            }
        }
        '''.parse
        val issues = validator.validate(content)
        assertTrue(issues.isEmpty())
    }
    
    @Test
    def void unions() {
        val content = '''
        InstructionSet TestISA {
            registers {
                union un1 {
                    long l;
                    int i;
                    short s;
                    char c;
                    int arr[10];
                    struct {float f; double d;} strct;
                };
                union un1 UR;
            }
            instructions {
                Inst1 {
                    encoding: b0000000 :: rs2[4:0] :: rs1[4:0] :: b000 :: rd[4:0] :: b0000000;  
                    behavior: {
                        UR.l = UR.s * UR.c / UR.i;
                        UR.strct.d = UR.arr[10];
                    }
                }
            }
        }
        '''.parse
        val issues = validator.validate(content)
        assertTrue(issues.isEmpty())
    }
    
    @Test
    def void spawn() {
        val content = '''
        InstructionSet TestISA {
            registers {
                int X[32];
                int PC;
            }
            functions {
                void maybe_corrupt_PC(int i) {
                    if ((i & 17) > 3)
                        PC = 0xdeadbeef;
                }
            }
            instructions {
                Inst1 {
                    encoding: b0000000 :: rs2[4:0] :: rs1[4:0] :: b000 :: rd[4:0] :: b0000000;  
                    behavior: {
                        int incr = X[rs1] * X[rs2];
                        spawn {
                            int i;
                            for (i = 0; i < 42; i += incr) {
                                maybe_corrupt_PC(i % X[rd]);
                            }
                        }
                    }
                }
            }
        }
        '''.parse
        val issues = validator.validate(content)
        assertTrue(issues.isEmpty())
    }
}
