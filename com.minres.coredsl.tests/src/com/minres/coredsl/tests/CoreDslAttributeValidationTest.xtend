/*
 * generated by Xtext 2.10.0
 */
package com.minres.coredsl.tests

import com.google.inject.Inject
import com.minres.coredsl.coreDsl.DescriptionContent
import org.eclipse.xtext.testing.InjectWith
import org.eclipse.xtext.testing.extensions.InjectionExtension
import org.eclipse.xtext.testing.util.ParseHelper
import org.eclipse.xtext.testing.validation.ValidationTestHelper
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.^extension.ExtendWith

import static org.junit.jupiter.api.Assertions.assertEquals
import static org.junit.jupiter.api.Assertions.assertNotNull
import static org.junit.jupiter.api.Assertions.assertTrue

import com.minres.coredsl.validation.KnownAttributes
import com.minres.coredsl.validation.CoreDslValidator

@ExtendWith(InjectionExtension)
@InjectWith(CoreDslInjectorProvider)
class CoreDslAttributeValidationTest {

	@Inject extension ParseHelper<DescriptionContent> parseHelper

	@Inject ValidationTestHelper validator

	@Test
	def void validAttributes() {
		val createValidAttribString = [ KnownAttributes.AttributeUsage usage |
			KnownAttributes.all.filter[it.allowedUsage.contains(usage)].map [
				"[[" + it.name + (it.paramCount > 0 ? "(" + ", 0".repeat(it.paramCount).substring(2) + ")" : "") + "]]"
			].join(" ")
		];

		val funcAttribString = createValidAttribString.apply(KnownAttributes.AttributeUsage.function);
		val declAttribString = createValidAttribString.apply(KnownAttributes.AttributeUsage.declaration);
		val instrAttribString = createValidAttribString.apply(KnownAttributes.AttributeUsage.instruction);

		val content = '''
			InstructionSet AttributeValidationTestInstructionSet {
			    architectural_state {
			        unsigned XLEN;
			        unsigned<XLEN> field «declAttribString»;
			    }
			    functions {
			    	void fun() «funcAttribString» {}
			    }
			    instructions «instrAttribString» {
			    	test «instrAttribString» {
			    		encoding: 0;
			    		args_disass: "";
			    		behavior: {}
			    	}
			    }
			}
			Core AttributeValidationTestCore provides AttributeValidationTestInstructionSet {
			    architectural_state {
			        XLEN=32;
			    }
			}
		'''.parse();

		val issues = validator.validate(content);
		for (issue : issues) {
			println(issue);
		}

		assertTrue(issues.isEmpty());
	}

	@Test
	def void invalidAttributePlacement() {
		val attribString = KnownAttributes.all.map [
			"[[" + it.name + (it.paramCount > 0 ? "(" + ", 0".repeat(it.paramCount).substring(2) + ")" : ""
    	) + "]]"
		].join(" ");

		val content = '''
			InstructionSet AttributeValidationTestInstructionSet {
			    architectural_state {
			        unsigned XLEN;
			        unsigned<XLEN> field «attribString»;
			    }
			    functions {
			    	void fun() «attribString» {}
			    }
			    instructions «attribString» {
			    	test «attribString» {
			    		encoding: 0;
			    		args_disass: "";
			    		behavior: {}
			    	}
			    }
			}
			Core AttributeValidationTestCore provides AttributeValidationTestInstructionSet {
			    architectural_state {
			        XLEN=32;
			    }
			}
		'''.parse();

		val issues = validator.validate(content);
		for (issue : issues) {
			println(issue);
			assertEquals(issue.code, CoreDslValidator.ILLEGAL_ATTRIBUTE);
		}

		// Every attribute appears in every possible location, so we expect
		// <location count> * <attribute count> - <valid placement count> issues.
		val validPlacementCount =
			KnownAttributes.all.map[it.allowedUsage.size].reduce[a, b|a + b] +
			KnownAttributes.all.filter[it.allowedUsage.contains(KnownAttributes.AttributeUsage.instruction)].size;
		assertEquals(issues.size, 4 * KnownAttributes.all.size - validPlacementCount);
	}

	@Test
	def void invalidAttributeParameters() {
		val createInvalidAttribString = [ KnownAttributes.AttributeUsage usage |
			KnownAttributes.all.filter[it.allowedUsage.contains(usage)].map [
				"[[" + it.name + "(" + ", 0".repeat(it.paramCount + 1).substring(2) + ")]]"
			].join(" ")
		];

		val funcAttribString = createInvalidAttribString.apply(KnownAttributes.AttributeUsage.function);
		val declAttribString = createInvalidAttribString.apply(KnownAttributes.AttributeUsage.declaration);
		val instrAttribString = createInvalidAttribString.apply(KnownAttributes.AttributeUsage.instruction);

		val content = '''
			InstructionSet AttributeValidationTestInstructionSet {
			    architectural_state {
			        unsigned XLEN;
			        unsigned<XLEN> field «declAttribString»;
			    }
			    functions {
			    	void fun() «funcAttribString» {}
			    }
			    instructions «instrAttribString» {
			    	test «instrAttribString» {
			    		encoding: 0;
			    		args_disass: "";
			    		behavior: {}
			    	}
			    }
			}
			Core AttributeValidationTestCore provides AttributeValidationTestInstructionSet {
			    architectural_state {
			        XLEN=32;
			    }
			}
		'''.parse();

		val issues = validator.validate(content);
		for (issue : issues) {
			println(issue);
			assertEquals(issue.code, CoreDslValidator.INVALID_ATTRIBUTE_PARAMETERS);
		}

		// we expect an issue for every valid attribute placement
		val validPlacementCount =
			KnownAttributes.all.map[it.allowedUsage.size].reduce[a, b|a + b] +
			KnownAttributes.all.filter[it.allowedUsage.contains(KnownAttributes.AttributeUsage.instruction)].size;
		assertEquals(issues.size, validPlacementCount);
	}
}
