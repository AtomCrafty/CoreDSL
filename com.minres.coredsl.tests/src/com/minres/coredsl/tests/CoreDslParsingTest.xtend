/*
 * generated by Xtext 2.10.0
 */
package com.minres.coredsl.tests

import com.google.inject.Inject
import org.eclipse.emf.ecore.util.EcoreUtil
import org.eclipse.xtext.testing.InjectWith
import org.eclipse.xtext.testing.XtextRunner
import org.eclipse.xtext.testing.util.ParseHelper
import org.junit.Test
import org.junit.runner.RunWith

import static org.junit.Assert.*
import com.minres.coredsl.coreDsl.DescriptionContent

@RunWith(XtextRunner)
@InjectWith(CoreDslInjectorProvider)
class CoreDslParsingTest {

    @Inject ParseHelper<DescriptionContent> parseHelper

    def String addInstructionContext(String str)'''
        InstructionSet TestISA {
            registers { 
                [[is_pc]] int PC ;
                int Xreg[32];
                float Freg[32];
            }
            instructions {
                «str»
            }
        }
    '''

    def String addInstructionSetContext(String str)'''
        InstructionSet TestISA {
            «str»
        }
    '''

    @Test
    def void parseInstrPRELU() {
        val input = '''
        PRELU {
            encoding: b0000000 :: rs2[4:0] :: rs1[4:0] :: b000 :: rd[4:0] :: b1111011;  
            args_disass:"{name(rd)}, {name(rs1)}, {name(rs2)}"; 
            behavior: {
                static float alpha = 0.2;  
                float input, new_alpha;
                input = Freg[rs1];  // read global F register
                if (rs2!=0) // avoid having an additional instruction for setting parameter
                    new_alpha = Freg[rs2];
                else 
                    new_alpha = alpha; // use the stored alpha when rs2==0
                if(input > 0)
                    Freg[rd] = input;
                else 
                    Freg[rd] = input*new_alpha; 
                if (rs2!=0)
                    alpha = new_alpha; // update internal alpha register
                }
        }
        '''
        val content = parseHelper.parse(input.addInstructionContext)
        assertEquals(1, content.definitions.size)
        val resource = content.eResource
        EcoreUtil.resolveAll(resource);
        assertEquals(0, resource.errors.size)
        assertEquals(0, resource.warnings.size)
    }

    @Test
    def void parseInstrSBOX() {
        val input = '''
        SBOX {
            encoding: b0000000 :: rs2[4:0] :: rs1[4:0] :: b000 :: rd[4:0] :: b1111011;  
            args_disass:"{name(rd)}, {name(rs1)}, {name(rs2)}"; 
            behavior: {
                unsigned int data_i;
                data_i = (unsigned int) Xreg[rs1];  
                // contents of array omitted for for brevity        
                const unsigned char sbox[256] = { 0x63, 0x7c, 0};  
                Xreg[rd] = sbox[data_i[31:24]] :: sbox[data_i[23:16]] :: sbox[data_i[15:8]] :: sbox[data_i[7:0]];
            }
        }
        '''
        val content = parseHelper.parse(input.addInstructionContext)
        assertEquals(1, content.definitions.size)
        val resource = content.eResource
        EcoreUtil.resolveAll(resource);
        assertEquals(0, resource.errors.size)
        assertEquals(0, resource.warnings.size)
    }

    @Test
    def void parseInstrSQRTFloatRegs() {
        val input = '''
            InstructionSet TestISA {
                registers {
                    float F_Ext[32];}
                instructions { 
                    vectorL {
                        encoding: b0000000 :: rs2[4:0] :: rs1[4:0] :: b000 :: rd[4:0] :: b1111011 ;
                        args_disass:"{name(rd)}, {name(rs1)}";
                        behavior: { 
                        float xc = F_Ext[rs1];     
                        float yc = F_Ext[rs1];
                        float sqdist = xc*xc + yc*yc;
                        //...SQRT(sqdist) computation
                        }
                    }
                }
            }
        '''
        val content = parseHelper.parse(input)
        assertEquals(1, content.definitions.size)
        val resource = content.eResource
        EcoreUtil.resolveAll(resource);
        assertEquals(0, resource.errors.size)
        assertEquals(0, resource.warnings.size)
    }

    @Test
    def void parseInstrSQRTUnionRegs() {
        val input = '''
            InstructionSet TestISA {
                registers {
                    union ISAXRegFile{
                        double doublePrec;  // for a double precision entry
                        struct vector2d {
                            float x_coord;
                            float y_coord;
                        } vector2d;         // for a 2d vector entry
                    } ISAXRegFile[32]; 
                }
                instructions { 
                    vectorL {
                        encoding: b0000000 :: rs2[4:0] :: rs1[4:0] :: b000 :: rd[4:0] :: b1111011 ;
                        args_disass:"{name(rd)}, {name(rs1)}";
                        behavior: { 
                            float xc = ISAXRegFile[rs1].vector2d.x_coord;
                            float yc = ISAXRegFile[rs1].vector2d.y_coord;
                            double result;
                            double sqdist = xc*xc + yc*yc;
                            if((sqdist==0) || (sqdist[30:23]==0xff))
                                result = 0; // avoid special cases
                            else
                                result = 1;//sqrt(sqdist);  
                            ISAXRegFile[rd].doublePrec = result;
                        }
                    }
                }
            }
        '''
        val content = parseHelper.parse(input)
        assertEquals(1, content.definitions.size)
        val resource = content.eResource
        EcoreUtil.resolveAll(resource);
        assertEquals(0, resource.errors.size)
        assertEquals(0, resource.warnings.size)
    }

    @Test
    def void parseInstrSpawn() {
        val input = '''
            InstructionSet TestISA {
                registers {
                    float Freg[32];
                    [[is_interlock_for=Freg]] bool F_ready[32] ;  // use attribute to indicate purpose of F_ready
                }
                instructions {
                    SIN {
                        encoding: b0000000 :: rs2[4:0] :: rs1[4:0] :: b000 :: rd[4:0] :: b1111011 ;
                        args_disass:"#{name(rd)}, {name(rs1)}";   
                        behavior: { 
                            double theta = Freg[rs1];
                            F_ready[rd] = false;            // synchronously mark result as unavailable
                            spawn {                         // asynchronously do the following block
                                    Freg[rd] = 0.01f;     // first perform the computation        
                                    F_ready[rd] = true;     // afterwards mark the result as ready
                            }
                        }
                    }
                }
            }
        '''
        val content = parseHelper.parse(input)
        assertEquals(1, content.definitions.size)
        val resource = content.eResource
        EcoreUtil.resolveAll(resource);
        assertEquals(0, resource.errors.size)
        assertEquals(0, resource.warnings.size)
    }

    @Test
    def void parseInstrZOL() {
        val input = '''
            InstructionSet TestISA {
                registers {
                	int PC;
                	int X[32];
                    unsigned int count, endpc, startpc;
                }
                functions {
                    void doZOL(){      
                        bool zolactive = true; 
                        while (zolactive) {         // keep executing while condition is true
                            if (PC == endpc) {      // evaluate loop body once per clock cycle
                                if (count != 0) {
                                    --count;
                                    PC = startpc;   // jump to loop start
                                } else
                                    zolactive = false;  // iteration limit reached, stop execution
                            }
                        }
                    }
                }
                instructions {
                    LP_SETUPI {
                        encoding: b0000000 :: rs2[4:0] :: rs1[4:0] :: b000 :: rd[4:0] :: b1111011 ;
                        args_disass:"{name(rs1)}, {name(rs2)}";
                        behavior: {
                            count   = X[rs1];
                            endpc   = PC + 4 + X[rs2]<<2; // use PC relative addressing to save bits
                            startpc = PC + 4; 
                            spawn doZOL(); // Keep running after LPSETUPI ends
                        }
                    }
                }
            }
        '''
        val content = parseHelper.parse(input)
        assertEquals(1, content.definitions.size)
        val resource = content.eResource
        EcoreUtil.resolveAll(resource);
        assertEquals(0, resource.errors.size)
        assertEquals(0, resource.warnings.size)
    }
}
