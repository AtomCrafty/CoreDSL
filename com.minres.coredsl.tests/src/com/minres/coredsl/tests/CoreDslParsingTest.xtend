/*
 * generated by Xtext 2.10.0
 */
package com.minres.coredsl.tests

import com.google.inject.Inject
import org.eclipse.emf.ecore.util.EcoreUtil
import org.eclipse.xtext.testing.InjectWith
import org.eclipse.xtext.testing.XtextRunner
import org.eclipse.xtext.testing.util.ParseHelper
import org.junit.Test
import org.junit.runner.RunWith

import static org.junit.Assert.*
import com.minres.coredsl.coreDsl.DescriptionContent

@RunWith(XtextRunner)
@InjectWith(CoreDslInjectorProvider)
class CoreDslParsingTest {

    @Inject ParseHelper<DescriptionContent> parseHelper

    def String addInstructionContext(String str)'''
        InstructionSet TestISA {
            registers { 
                [[is_pc]] int PC ;
                int Xreg[32];
                float Freg[32];
            }
            instructions {
                «str»
            }
        }
    '''

    def String addInstructionSetContext(String str)'''
        InstructionSet TestISA {
            «str»
        }
    '''

    @Test
    def void parseInstrPRELU() {
        val input = '''
        PRELU {
            encoding: b0000000 :: rs2[4:0] :: rs1[4:0] :: b000 :: rd[4:0] :: b1111011;  
            args_disass:"{name(rd)}, {name(rs1)}, {name(rs2)}"; 
            behavior: {
                static float alpha = 0.2;  
                float input, new_alpha;
                input = Freg[rs1];  // read global F register
                if (rs2!=0) // avoid having an additional instruction for setting parameter
                    new_alpha = Freg[rs2];
                else 
                    new_alpha = alpha; // use the stored alpha when rs2==0
                if(input > 0)
                    Freg[rd] = input;
                else 
                    Freg[rd] = input*new_alpha; 
                if (rs2!=0)
                    alpha = new_alpha; // update internal alpha register
                }
        }
        '''
        val content = parseHelper.parse(input.addInstructionContext)
        assertEquals(1, content.definitions.size)
        val resource = content.eResource
        EcoreUtil.resolveAll(resource);
        assertEquals(0, resource.errors.size)
        assertEquals(0, resource.warnings.size)
    }

    @Test
    def void parseInstrSBOX() {
        val input = '''
        SBOX {
            encoding: b0000000 :: rs2[4:0] :: rs1[4:0] :: b000 :: rd[4:0] :: b1111011;  
            args_disass:"{name(rd)}, {name(rs1)}, {name(rs2)}"; 
            behavior: {
                unsigned int data_i;
                data_i = (unsigned int) Xreg[rs1];  
                // contents of array omitted for for brevity        
                const unsigned char sbox[256] = { 0x63, 0x7c, 0};  
                Xreg[rd] = sbox[data_i[31:24]] :: sbox[data_i[23:16]] :: sbox[data_i[15:8]] :: sbox[data_i[7:0]];
            }
        }
        '''
        val content = parseHelper.parse(input.addInstructionContext)
        assertEquals(1, content.definitions.size)
        val resource = content.eResource
        EcoreUtil.resolveAll(resource);
        assertEquals(0, resource.errors.size)
        assertEquals(0, resource.warnings.size)
    }

}
