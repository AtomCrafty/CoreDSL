/*
 * generated by Xtext 2.10.0
 */
package com.minres.coredsl.tests

import com.google.inject.Inject
import com.minres.coredsl.coreDsl.AssignmentExpression
import com.minres.coredsl.coreDsl.CompoundStatement
import com.minres.coredsl.coreDsl.DataTypes
import com.minres.coredsl.coreDsl.Declaration
import com.minres.coredsl.coreDsl.DescriptionContent
import com.minres.coredsl.coreDsl.ExpressionStatement
import com.minres.coredsl.coreDsl.InstructionSet
import com.minres.coredsl.coreDsl.IntegerConstant
import com.minres.coredsl.coreDsl.PodSpecifier
import com.minres.coredsl.coreDsl.PrimaryExpression
import org.eclipse.xtext.testing.InjectWith
import org.eclipse.xtext.testing.XtextRunner
import org.eclipse.xtext.testing.util.ParseHelper
import org.eclipse.xtext.testing.validation.ValidationTestHelper
import org.junit.Test
import org.junit.runner.RunWith

import static org.junit.Assert.assertEquals
import static org.junit.Assert.assertFalse

@RunWith(XtextRunner)
@InjectWith(CoreDslInjectorProvider)
class CoreDslParsingTest {

    @Inject extension ParseHelper<DescriptionContent> parseHelper

    @Inject ValidationTestHelper validator

    def CharSequence addInstructionContext(CharSequence str)'''
        InstructionSet TestISA {
            registers { 
                [[is_pc]] int PC ;
                int Xreg[32];
                float Freg[32];
            }
            instructions {
                «str»
            }
        }
    '''
    
    def CharSequence addBehaviorContext(CharSequence str) {
    	return addInstructionContext('''
    		FOO {
				encoding: b0000000 :: rs2[4:0] :: rs1[4:0] :: b000 :: rd[4:0] :: b1111011;  
				args_disass: "{name(rd)}, {name(rs1)}, {name(rs2)}";
				behavior: {
					«str»
				}
			}
    	''')
    }

    @Test
    def void parseInstrPRELU() {
        val content = '''
        PRELU {
            encoding: b0000000 :: rs2[4:0] :: rs1[4:0] :: b000 :: rd[4:0] :: b1111011;  
            args_disass:"{name(rd)}, {name(rs1)}, {name(rs2)}"; 
            behavior: {
                static float alpha = 0.2;  
                float input, new_alpha;
                input = Freg[rs1];  // read global F register
                if (rs2!=0) // avoid having an additional instruction for setting parameter
                    new_alpha = Freg[rs2];
                else 
                    new_alpha = alpha; // use the stored alpha when rs2==0
                if(input > 0)
                    Freg[rd] = input;
                else 
                    Freg[rd] = input*new_alpha; 
                if (rs2!=0)
                    alpha = new_alpha; // update internal alpha register
                }
        }
        '''.addInstructionContext.parse
        validator.assertNoErrors(content)
    }

    @Test
    def void parseInstrSBOX() {
        val content = '''
        SBOX {
            encoding: b0000000 :: rs2[4:0] :: rs1[4:0] :: b000 :: rd[4:0] :: b1111011;  
            args_disass:"{name(rd)}, {name(rs1)}, {name(rs2)}"; 
            behavior: {
                unsigned int data_i;
                data_i = (unsigned int) Xreg[rs1];  
                // contents of array omitted for for brevity        
                const unsigned char sbox[256] = { 0x63, 0x7c, 0};  
                Xreg[rd] = sbox[data_i[31:24]] :: sbox[data_i[23:16]] :: sbox[data_i[15:8]] :: sbox[data_i[7:0]];
            }
        }
        '''.addInstructionContext.parse
        validator.assertNoErrors(content)
    }

    @Test
    def void parseInstrSQRTFloatRegs() {
        val content = '''
            InstructionSet TestISA {
                registers {
                    float F_Ext[32];}
                instructions { 
                    vectorL {
                        encoding: b0000000 :: rs2[4:0] :: rs1[4:0] :: b000 :: rd[4:0] :: b1111011 ;
                        args_disass:"{name(rd)}, {name(rs1)}";
                        behavior: { 
                        float xc = F_Ext[rs1];     
                        float yc = F_Ext[rs1];
                        float sqdist = xc*xc + yc*yc;
                        //...SQRT(sqdist) computation
                        }
                    }
                }
            }
        '''.parse
        validator.assertNoErrors(content)
    }

    @Test
    def void parseInstrSQRTUnionRegs() {
        val content = '''
            InstructionSet TestISA {
                registers {
                    union ISAXRegFile{
                        double doublePrec;  // for a double precision entry
                        struct vector2d {
                            float x_coord;
                            float y_coord;
                        } vector2d;         // for a 2d vector entry
                    } ISAXRegFile[32]; 
                }
                instructions { 
                    vectorL {
                        encoding: b0000000 :: rs2[4:0] :: rs1[4:0] :: b000 :: rd[4:0] :: b1111011 ;
                        args_disass:"{name(rd)}, {name(rs1)}";
                        behavior: { 
                            float xc = ISAXRegFile[rs1].vector2d.x_coord;
                            float yc = ISAXRegFile[rs1].vector2d.y_coord;
                            double result;
                            double sqdist = xc*xc + yc*yc;
                            if((sqdist==0) || (sqdist[30:23]==0xff))
                                result = 0; // avoid special cases
                            else
                                result = 1;//sqrt(sqdist);  
                            ISAXRegFile[rd].doublePrec = result;
                        }
                    }
                }
            }
        '''.parse
        validator.assertNoErrors(content)
    }

    @Test
    def void parseInstrSpawn() {
        val content = '''
            InstructionSet TestISA {
                registers {
                	[[is_pc]] int PC;
                    float Freg[32];
                    bool F_ready[32] [[is_interlock_for=Freg]];  // use attribute to indicate purpose of F_ready
                }
                instructions {
                    SIN {
                        encoding: b0000000 :: rs2[4:0] :: rs1[4:0] :: b000 :: rd[4:0] :: b1111011 ;
                        args_disass:"#{name(rd)}, {name(rs1)}";   
                        behavior: { 
                            double theta = Freg[rs1];
                            F_ready[rd] = false;            // synchronously mark result as unavailable
                            spawn {                         // asynchronously do the following block
                                    Freg[rd] = 0.01f;     // first perform the computation        
                                    F_ready[rd] = true;     // afterwards mark the result as ready
                            }
                        }
                    }
                }
            }
        '''.parse
        validator.assertNoErrors(content)
    }

    @Test
    def void parseInstrZOL() {
        val content = '''
            InstructionSet TestISA {
                registers {
                	int PC;
                	int X[32];
                    unsigned int count, endpc, startpc;
                }
                functions {
                    void doZOL(){      
                        bool zolactive = true; 
                        while (zolactive) {         // keep executing while condition is true
                            if (PC == endpc) {      // evaluate loop body once per clock cycle
                                if (count != 0) {
                                    --count;
                                    PC = startpc;   // jump to loop start
                                } else
                                    zolactive = false;  // iteration limit reached, stop execution
                            }
                        }
                    }
                }
                instructions {
                    LP_SETUPI {
                        encoding: b0000000 :: rs2[4:0] :: rs1[4:0] :: b000 :: rd[4:0] :: b1111011 ;
                        args_disass:"{name(rs1)}, {name(rs2)}";
                        behavior: {
                            count   = X[rs1];
                            endpc   = PC + 4 + X[rs2]<<2; // use PC relative addressing to save bits
                            startpc = PC + 4; 
                            spawn doZOL(); // Keep running after LPSETUPI ends
                        }
                    }
                }
            }
        '''.parse
        validator.assertNoErrors(content)
    }
    
    @Test
    def void parseIntLiterals() {
    	val content = addBehaviorContext('''
			int i;
			// C syntax
			i = 42;
			i = 0x2A;
			i = 052;
			i = 0b101010;
			
			// Verilog syntax
			i = 6'd42;
			i = 6'h2a;
			i = 6'o52;
			i = 6'b101010;
    	''').parse
    	validator.assertNoErrors(content)
    	
    	val compound = ((content.definitions.get(0) as InstructionSet).instr.get(0).behavior as CompoundStatement)
		for (el : compound.items.subList(1, compound.items.size())) {
			val expr = (el as ExpressionStatement).expr as AssignmentExpression
			val rhs = (expr.rights.get(0) as PrimaryExpression).constant as IntegerConstant
			assertEquals(rhs.value.intValue, 42)
		}
    }
    
    @Test
    def void parseCustomIntTypes() {
    	val content = addBehaviorContext('''
    		int<17> i17;
    	''').parse
    	validator.assertNoErrors(content)
    	val decl = 
    		(((content.definitions.get(0) as InstructionSet)
    			.instr.get(0).behavior as CompoundStatement)
    				.items.get(0) as Declaration)
		val type = (decl.type as PodSpecifier).dataType.get(0)
		val size = (decl.size.size.get(0).constant as IntegerConstant).value.intValue
		assertEquals(type, DataTypes.INT)
		assertEquals(size, 17)
		
		val content2 = addBehaviorContext('''
			int<1,1> i_invalid;
		''').parse
		val issues = validator.validate(content2)
		assertFalse(issues.isEmpty())
    }
}
