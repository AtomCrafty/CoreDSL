/**
 * generated by Xtext 2.10.0
 */
package com.minres.coredsl.tests;

import com.google.inject.Inject;
import com.minres.coredsl.coreDsl.DescriptionContent;
import com.minres.coredsl.coreDsl.ISA;
import com.minres.coredsl.coreDsl.Instruction;
import com.minres.coredsl.coreDsl.InstructionSet;
import com.minres.coredsl.tests.CoreDslInjectorProvider;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.emf.ecore.util.EcoreUtil;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.testing.InjectWith;
import org.eclipse.xtext.testing.XtextRunner;
import org.eclipse.xtext.testing.util.ParseHelper;
import org.eclipse.xtext.xbase.lib.Exceptions;
import org.eclipse.xtext.xbase.lib.Functions.Function0;
import org.junit.Assert;
import org.junit.Test;
import org.junit.runner.RunWith;

@RunWith(XtextRunner.class)
@InjectWith(CoreDslInjectorProvider.class)
@SuppressWarnings("all")
public class CoreDslParsingTest {
  @Inject
  private ParseHelper<DescriptionContent> parseHelper;
  
  private final String isa1 = new Function0<String>() {
    @Override
    public String apply() {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("InstructionSet RV32I {");
      _builder.newLine();
      _builder.append("    ");
      _builder.append("constants {");
      _builder.newLine();
      _builder.append("        ");
      _builder.append("unsigned int XLEN, FLEN;");
      _builder.newLine();
      _builder.append("        ");
      _builder.append("unsigned CSR_SIZE = 4096;");
      _builder.newLine();
      _builder.append("        ");
      _builder.append("unsigned REG_FILE_SIZE=32;");
      _builder.newLine();
      _builder.append("    ");
      _builder.append("}");
      _builder.newLine();
      _builder.append("    ");
      _builder.append("address_spaces {");
      _builder.newLine();
      _builder.append("        ");
      _builder.append("char MEM[1<<XLEN];");
      _builder.newLine();
      _builder.append("        ");
      _builder.append("unsigned CSR[CSR_SIZE];");
      _builder.newLine();
      _builder.append("    ");
      _builder.append("}            ");
      _builder.newLine();
      _builder.append("    ");
      _builder.append("registers { ");
      _builder.newLine();
      _builder.append("    \t");
      _builder.append("[[is_pc]] unsigned int PC ;");
      _builder.newLine();
      _builder.append("    \t");
      _builder.append("int X[REG_FILE_SIZE];");
      _builder.newLine();
      _builder.append("    ");
      _builder.append("} ");
      _builder.newLine();
      _builder.append("    ");
      _builder.append("instructions { ");
      _builder.newLine();
      _builder.append("        ");
      _builder.append("ADDI {");
      _builder.newLine();
      _builder.append("            ");
      _builder.append("encoding: imm[11:0] | rs1[4:0] | b000 | rd[4:0] | b0010011;");
      _builder.newLine();
      _builder.append("            ");
      _builder.append("behavior: {");
      _builder.newLine();
      _builder.append("                ");
      _builder.append("X[rd] = X[rs1] + (int)imm;");
      _builder.newLine();
      _builder.append("            ");
      _builder.append("}");
      _builder.newLine();
      _builder.append("        ");
      _builder.append("}");
      _builder.newLine();
      _builder.append("        ");
      _builder.append("SLTI {");
      _builder.newLine();
      _builder.append("            ");
      _builder.append("encoding: imm[11:0] | rs1[4:0] | b010 | rd[4:0] | b0010011;");
      _builder.newLine();
      _builder.append("            ");
      _builder.append("behavior: {");
      _builder.newLine();
      _builder.append("                ");
      _builder.append("X[rd] = X[rs1] < (int)imm? 1 : 0;");
      _builder.newLine();
      _builder.append("            ");
      _builder.append("}");
      _builder.newLine();
      _builder.append("        ");
      _builder.append("}");
      _builder.newLine();
      _builder.append("        ");
      _builder.append("SLTIU {");
      _builder.newLine();
      _builder.append("            ");
      _builder.append("encoding: imm[11:0] | rs1[4:0] | b011 | rd[4:0] | b0010011;");
      _builder.newLine();
      _builder.append("            ");
      _builder.append("behavior: {");
      _builder.newLine();
      _builder.append("                ");
      _builder.append("X[rd] = X[rs1] < (unsigned int)imm? 1 : 0;");
      _builder.newLine();
      _builder.append("            ");
      _builder.append("}");
      _builder.newLine();
      _builder.append("        ");
      _builder.append("}");
      _builder.newLine();
      _builder.append("        ");
      _builder.append("SW {");
      _builder.newLine();
      _builder.append("            ");
      _builder.append("encoding: imm[11:5] | rs2[4:0] | rs1[4:0] | b010 | imm[4:0] | b0100011;");
      _builder.newLine();
      _builder.append("            ");
      _builder.append("behavior: {");
      _builder.newLine();
      _builder.append("                ");
      _builder.append("int offset = X[rs1] + (int)imm;");
      _builder.newLine();
      _builder.append("                ");
      _builder.append("MEM[offset] = X[rs2];");
      _builder.newLine();
      _builder.append("            ");
      _builder.append("}");
      _builder.newLine();
      _builder.append("        ");
      _builder.append("}");
      _builder.newLine();
      _builder.append("        ");
      _builder.append("JAL[[no_cont]] {");
      _builder.newLine();
      _builder.append("            ");
      _builder.append("encoding:imm[20:20]s | imm[10:1]s | imm[11:11]s | imm[19:12]s | rd[4:0] | b1101111;");
      _builder.newLine();
      _builder.append("            ");
      _builder.append("behavior: {");
      _builder.newLine();
      _builder.append("            ");
      _builder.append("if(rd!=0) X[rd] = (unsigned)PC;");
      _builder.newLine();
      _builder.append("                ");
      _builder.append("PC = PC+(signed)imm;");
      _builder.newLine();
      _builder.append("            ");
      _builder.append("}");
      _builder.newLine();
      _builder.append("        ");
      _builder.append("}");
      _builder.newLine();
      _builder.append("    ");
      _builder.append("}");
      _builder.newLine();
      _builder.append("}");
      _builder.newLine();
      return _builder.toString();
    }
  }.apply();
  
  @Test
  public void loadModel() {
    try {
      final DescriptionContent content = this.parseHelper.parse(this.isa1);
      Assert.assertEquals(1, content.getDefinitions().size());
      final Resource resource = content.eResource();
      EcoreUtil.resolveAll(resource);
      Assert.assertEquals(0, resource.getErrors().size());
      Assert.assertEquals(0, resource.getWarnings().size());
      ISA _get = content.getDefinitions().get(0);
      final InstructionSet result = ((InstructionSet) _get);
      Assert.assertNotNull(result);
      Assert.assertEquals("RV32I", result.getName());
      Assert.assertNull(result.getSuperType());
      Assert.assertEquals(2, result.getSpaces().size());
      Assert.assertNotNull(result.getRegs());
      Assert.assertNotNull(result.getInstr());
      Assert.assertEquals(2, result.getRegs().size());
      Assert.assertEquals(5, result.getInstr().size());
      final Instruction i0 = result.getInstr().get(0);
      Assert.assertEquals("ADDI", i0.getName());
      Assert.assertEquals(5, i0.getEncoding().getFields().size());
      final Instruction i1 = result.getInstr().get(1);
      Assert.assertEquals("SLTI", i1.getName());
      Assert.assertEquals(5, i1.getEncoding().getFields().size());
      final Instruction i2 = result.getInstr().get(2);
      Assert.assertEquals("SLTIU", i2.getName());
      Assert.assertEquals(5, i2.getEncoding().getFields().size());
      final Instruction i3 = result.getInstr().get(3);
      Assert.assertEquals("SW", i3.getName());
      Assert.assertEquals(6, i3.getEncoding().getFields().size());
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  private final String vec2d_ = new Function0<String>() {
    @Override
    public String apply() {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("InstructionSet Vec2D {");
      _builder.newLine();
      _builder.append("    ");
      _builder.append("registers{");
      _builder.newLine();
      _builder.append("        ");
      _builder.append("union ISAXRegFile {");
      _builder.newLine();
      _builder.append("            ");
      _builder.append("double doublePrec;  // for a double precision entry");
      _builder.newLine();
      _builder.append("            ");
      _builder.append("struct vector2d {");
      _builder.newLine();
      _builder.append("\t            ");
      _builder.append("float x_coord;");
      _builder.newLine();
      _builder.append("\t            ");
      _builder.append("float y_coord;");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("} vector2d;");
      _builder.newLine();
      _builder.append("        ");
      _builder.append("} ISAXRegFile[32];");
      _builder.newLine();
      _builder.append("       \t");
      _builder.append("struct simd{");
      _builder.newLine();
      _builder.append("       \t\t");
      _builder.append("unsigned a1;");
      _builder.newLine();
      _builder.append("       \t\t");
      _builder.append("unsigned a1;");
      _builder.newLine();
      _builder.append("       \t\t");
      _builder.append("unsigned a3;");
      _builder.newLine();
      _builder.append("       \t\t");
      _builder.append("unsigned a4;");
      _builder.newLine();
      _builder.append("       \t");
      _builder.append("};");
      _builder.newLine();
      _builder.append("       \t");
      _builder.append("typedef struct simd simd_t;");
      _builder.newLine();
      _builder.append("       \t");
      _builder.append("simd_t reg[32];");
      _builder.newLine();
      _builder.append("    ");
      _builder.append("}");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("functions{");
      _builder.newLine();
      _builder.append("\t    ");
      _builder.append("double sqrt(float x) {");
      _builder.newLine();
      _builder.append("\t        ");
      _builder.append("const double precision = 0.00001;");
      _builder.newLine();
      _builder.append("\t        ");
      _builder.append("double result = 1;");
      _builder.newLine();
      _builder.append("\t        ");
      _builder.append("double check = 1 - x;");
      _builder.newLine();
      _builder.append("\t        ");
      _builder.append("if (check < 0)");
      _builder.newLine();
      _builder.append("\t            ");
      _builder.append("check = -check;");
      _builder.newLine();
      _builder.append("\t        ");
      _builder.append("while (check >= precision) {");
      _builder.newLine();
      _builder.append("\t            ");
      _builder.append("result = (x / result + result) / 2.0;");
      _builder.newLine();
      _builder.append("\t            ");
      _builder.append("check = result * result - x;");
      _builder.newLine();
      _builder.append("\t            ");
      _builder.append("if (check < 0)");
      _builder.newLine();
      _builder.append("\t                ");
      _builder.append("check = -check;");
      _builder.newLine();
      _builder.append("\t        ");
      _builder.append("}");
      _builder.newLine();
      _builder.append("\t        ");
      _builder.append("return result;");
      _builder.newLine();
      _builder.append("\t    ");
      _builder.append("}");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("instructions{");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("VectorL{");
      _builder.newLine();
      _builder.append("\t\t    ");
      _builder.append("encoding: b10101 | rd[4:0] | rs1[4:0];");
      _builder.newLine();
      _builder.append("\t\t    ");
      _builder.append("args_disass:\"{name(rd)}, {name(rs1)}\";");
      _builder.newLine();
      _builder.append("            ");
      _builder.append("behavior: {");
      _builder.newLine();
      _builder.append("\t\t\t    ");
      _builder.append("float xc = ISAXRegFile[rs1].vector2d.x_coord;");
      _builder.newLine();
      _builder.append("\t\t\t    ");
      _builder.append("float yc = ISAXRegFile[rs1].vector2d.y_coord;");
      _builder.newLine();
      _builder.append("\t\t\t    ");
      _builder.append("double result;");
      _builder.newLine();
      _builder.append("\t\t\t    ");
      _builder.append("double sqdist = xc*xc + yc*yc;");
      _builder.newLine();
      _builder.append("\t\t\t    ");
      _builder.append("if(sqdist==0 || sqdist[30:23]==0xff)");
      _builder.newLine();
      _builder.append("\t\t\t        ");
      _builder.append("result = 0; // avoid special cases");
      _builder.newLine();
      _builder.append("\t\t\t    ");
      _builder.append("else");
      _builder.newLine();
      _builder.append("\t\t\t        ");
      _builder.append("result = sqrt(sqdist);");
      _builder.newLine();
      _builder.append("\t\t\t    ");
      _builder.append("ISAXRegFile[rd].doublePrec = result;");
      _builder.newLine();
      _builder.append("\t\t    ");
      _builder.append("}");
      _builder.newLine();
      _builder.append("\t    ");
      _builder.append("}");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("}");
      _builder.newLine();
      return _builder.toString();
    }
  }.apply();
  
  @Test
  public void loaVec2D() {
    try {
      final DescriptionContent content = this.parseHelper.parse(this.vec2d_);
      Assert.assertEquals(1, content.getDefinitions().size());
      final Resource resource = content.eResource();
      EcoreUtil.resolveAll(resource);
      Assert.assertEquals(0, resource.getErrors().size());
      Assert.assertEquals(0, resource.getWarnings().size());
      ISA _get = content.getDefinitions().get(0);
      final InstructionSet instructionSet = ((InstructionSet) _get);
      Assert.assertNotNull(instructionSet);
      Assert.assertEquals("Vec2D", instructionSet.getName());
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
}
