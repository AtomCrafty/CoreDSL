/**
 * generated by Xtext 2.10.0
 */
package com.minres.coredsl.tests;

import com.google.inject.Inject;
import com.minres.coredsl.coreDsl.DescriptionContent;
import com.minres.coredsl.coreDsl.ISA;
import com.minres.coredsl.coreDsl.Instruction;
import com.minres.coredsl.coreDsl.InstructionSet;
import com.minres.coredsl.tests.CoreDslInjectorProvider;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.emf.ecore.util.EcoreUtil;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.testing.InjectWith;
import org.eclipse.xtext.testing.XtextRunner;
import org.eclipse.xtext.testing.util.ParseHelper;
import org.eclipse.xtext.xbase.lib.Exceptions;
import org.junit.Assert;
import org.junit.Test;
import org.junit.runner.RunWith;

@RunWith(XtextRunner.class)
@InjectWith(CoreDslInjectorProvider.class)
@SuppressWarnings("all")
public class CoreDslLoadTest {
  @Inject
  private ParseHelper<DescriptionContent> parseHelper;
  
  @Test
  public void loadSimpleModel() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("InstructionSet RV32I {");
      _builder.newLine();
      _builder.append("    ");
      _builder.append("constants {");
      _builder.newLine();
      _builder.append("        ");
      _builder.append("unsigned int XLEN, FLEN;");
      _builder.newLine();
      _builder.append("        ");
      _builder.append("unsigned CSR_SIZE = 4096;");
      _builder.newLine();
      _builder.append("        ");
      _builder.append("unsigned REG_FILE_SIZE=32;");
      _builder.newLine();
      _builder.append("    ");
      _builder.append("}");
      _builder.newLine();
      _builder.append("    ");
      _builder.append("address_spaces {");
      _builder.newLine();
      _builder.append("        ");
      _builder.append("char MEM[1<<XLEN];");
      _builder.newLine();
      _builder.append("        ");
      _builder.append("unsigned CSR[CSR_SIZE];");
      _builder.newLine();
      _builder.append("    ");
      _builder.append("}            ");
      _builder.newLine();
      _builder.append("    ");
      _builder.append("registers { ");
      _builder.newLine();
      _builder.append("    \t");
      _builder.append("[[is_pc]] unsigned int PC ;");
      _builder.newLine();
      _builder.append("    \t");
      _builder.append("int X[REG_FILE_SIZE];");
      _builder.newLine();
      _builder.append("    ");
      _builder.append("} ");
      _builder.newLine();
      _builder.append("    ");
      _builder.append("instructions { ");
      _builder.newLine();
      _builder.append("        ");
      _builder.append("ADDI {");
      _builder.newLine();
      _builder.append("            ");
      _builder.append("encoding: imm[11:0] | rs1[4:0] | b000 | rd[4:0] | b0010011;");
      _builder.newLine();
      _builder.append("            ");
      _builder.append("behavior: {");
      _builder.newLine();
      _builder.append("                ");
      _builder.append("X[rd] = X[rs1] + (int)imm;");
      _builder.newLine();
      _builder.append("            ");
      _builder.append("}");
      _builder.newLine();
      _builder.append("        ");
      _builder.append("}");
      _builder.newLine();
      _builder.append("        ");
      _builder.append("SLTI {");
      _builder.newLine();
      _builder.append("            ");
      _builder.append("encoding: imm[11:0] | rs1[4:0] | b010 | rd[4:0] | b0010011;");
      _builder.newLine();
      _builder.append("            ");
      _builder.append("behavior: {");
      _builder.newLine();
      _builder.append("                ");
      _builder.append("X[rd] = X[rs1] < (int)imm? 1 : 0;");
      _builder.newLine();
      _builder.append("            ");
      _builder.append("}");
      _builder.newLine();
      _builder.append("        ");
      _builder.append("}");
      _builder.newLine();
      _builder.append("        ");
      _builder.append("SLTIU {");
      _builder.newLine();
      _builder.append("            ");
      _builder.append("encoding: imm[11:0] | rs1[4:0] | b011 | rd[4:0] | b0010011;");
      _builder.newLine();
      _builder.append("            ");
      _builder.append("behavior: {");
      _builder.newLine();
      _builder.append("                ");
      _builder.append("X[rd] = X[rs1] < (unsigned int)imm? 1 : 0;");
      _builder.newLine();
      _builder.append("            ");
      _builder.append("}");
      _builder.newLine();
      _builder.append("        ");
      _builder.append("}");
      _builder.newLine();
      _builder.append("        ");
      _builder.append("SW {");
      _builder.newLine();
      _builder.append("            ");
      _builder.append("encoding: imm[11:5] | rs2[4:0] | rs1[4:0] | b010 | imm[4:0] | b0100011;");
      _builder.newLine();
      _builder.append("            ");
      _builder.append("behavior: {");
      _builder.newLine();
      _builder.append("                ");
      _builder.append("int offset = X[rs1] + (int)imm;");
      _builder.newLine();
      _builder.append("                ");
      _builder.append("MEM[offset] = X[rs2];");
      _builder.newLine();
      _builder.append("            ");
      _builder.append("}");
      _builder.newLine();
      _builder.append("        ");
      _builder.append("}");
      _builder.newLine();
      _builder.append("        ");
      _builder.append("JAL[[no_cont]] {");
      _builder.newLine();
      _builder.append("            ");
      _builder.append("encoding:imm[20:20]s | imm[10:1]s | imm[11:11]s | imm[19:12]s | rd[4:0] | b1101111;");
      _builder.newLine();
      _builder.append("            ");
      _builder.append("behavior: {");
      _builder.newLine();
      _builder.append("            ");
      _builder.append("if(rd!=0) X[rd] = (unsigned)PC;");
      _builder.newLine();
      _builder.append("                ");
      _builder.append("PC = PC+(signed)imm;");
      _builder.newLine();
      _builder.append("            ");
      _builder.append("}");
      _builder.newLine();
      _builder.append("        ");
      _builder.append("}");
      _builder.newLine();
      _builder.append("    ");
      _builder.append("}");
      _builder.newLine();
      _builder.append("}");
      _builder.newLine();
      final String input = _builder.toString();
      final DescriptionContent content = this.parseHelper.parse(input);
      Assert.assertEquals(1, content.getDefinitions().size());
      final Resource resource = content.eResource();
      EcoreUtil.resolveAll(resource);
      Assert.assertEquals(0, resource.getErrors().size());
      Assert.assertEquals(0, resource.getWarnings().size());
      ISA _get = content.getDefinitions().get(0);
      final InstructionSet result = ((InstructionSet) _get);
      Assert.assertNotNull(result);
      Assert.assertEquals("RV32I", result.getName());
      Assert.assertNull(result.getSuperType());
      Assert.assertEquals(2, result.getSpaces().size());
      Assert.assertNotNull(result.getRegs());
      Assert.assertNotNull(result.getInstr());
      Assert.assertEquals(2, result.getRegs().size());
      Assert.assertEquals(5, result.getInstr().size());
      final Instruction i0 = result.getInstr().get(0);
      Assert.assertEquals("ADDI", i0.getName());
      Assert.assertEquals(5, i0.getEncoding().getFields().size());
      final Instruction i1 = result.getInstr().get(1);
      Assert.assertEquals("SLTI", i1.getName());
      Assert.assertEquals(5, i1.getEncoding().getFields().size());
      final Instruction i2 = result.getInstr().get(2);
      Assert.assertEquals("SLTIU", i2.getName());
      Assert.assertEquals(5, i2.getEncoding().getFields().size());
      final Instruction i3 = result.getInstr().get(3);
      Assert.assertEquals("SW", i3.getName());
      Assert.assertEquals(6, i3.getEncoding().getFields().size());
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  @Test
  public void loadSqrt() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("InstructionSet Vec2D {");
      _builder.newLine();
      _builder.append("    ");
      _builder.append("registers{");
      _builder.newLine();
      _builder.append("        ");
      _builder.append("union ISAXRegFile {");
      _builder.newLine();
      _builder.append("            ");
      _builder.append("double doublePrec;  // for a double precision entry");
      _builder.newLine();
      _builder.append("            ");
      _builder.append("struct vector2d {");
      _builder.newLine();
      _builder.append("\t            ");
      _builder.append("float x_coord;");
      _builder.newLine();
      _builder.append("\t            ");
      _builder.append("float y_coord;");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("} vector2d;");
      _builder.newLine();
      _builder.append("        ");
      _builder.append("} ISAXRegFile[32];");
      _builder.newLine();
      _builder.append("       \t");
      _builder.append("struct simd{");
      _builder.newLine();
      _builder.append("       \t\t");
      _builder.append("unsigned a1;");
      _builder.newLine();
      _builder.append("       \t\t");
      _builder.append("unsigned a1;");
      _builder.newLine();
      _builder.append("       \t\t");
      _builder.append("unsigned a3;");
      _builder.newLine();
      _builder.append("       \t\t");
      _builder.append("unsigned a4;");
      _builder.newLine();
      _builder.append("       \t");
      _builder.append("};");
      _builder.newLine();
      _builder.append("       \t");
      _builder.append("typedef struct simd simd_t;");
      _builder.newLine();
      _builder.append("       \t");
      _builder.append("simd_t reg[32];");
      _builder.newLine();
      _builder.append("    ");
      _builder.append("}");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("functions{");
      _builder.newLine();
      _builder.append("\t    ");
      _builder.append("double sqrt(float x) {");
      _builder.newLine();
      _builder.append("\t        ");
      _builder.append("const double precision = 0.00001;");
      _builder.newLine();
      _builder.append("\t        ");
      _builder.append("double result = 1;");
      _builder.newLine();
      _builder.append("\t        ");
      _builder.append("double check = 1 - x;");
      _builder.newLine();
      _builder.append("\t        ");
      _builder.append("if (check < 0)");
      _builder.newLine();
      _builder.append("\t            ");
      _builder.append("check = -check;");
      _builder.newLine();
      _builder.append("\t        ");
      _builder.append("while (check >= precision) {");
      _builder.newLine();
      _builder.append("\t            ");
      _builder.append("result = (x / result + result) / 2.0;");
      _builder.newLine();
      _builder.append("\t            ");
      _builder.append("check = result * result - x;");
      _builder.newLine();
      _builder.append("\t            ");
      _builder.append("if (check < 0)");
      _builder.newLine();
      _builder.append("\t                ");
      _builder.append("check = -check;");
      _builder.newLine();
      _builder.append("\t        ");
      _builder.append("}");
      _builder.newLine();
      _builder.append("\t        ");
      _builder.append("return result;");
      _builder.newLine();
      _builder.append("\t    ");
      _builder.append("}");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("instructions{");
      _builder.newLine();
      _builder.append("\t\t");
      _builder.append("VectorL{");
      _builder.newLine();
      _builder.append("\t\t    ");
      _builder.append("encoding: b10101 | rd[4:0] | rs1[4:0];");
      _builder.newLine();
      _builder.append("\t\t    ");
      _builder.append("args_disass:\"{name(rd)}, {name(rs1)}\";");
      _builder.newLine();
      _builder.append("            ");
      _builder.append("behavior: {");
      _builder.newLine();
      _builder.append("\t\t\t    ");
      _builder.append("float xc = ISAXRegFile[rs1].vector2d.x_coord;");
      _builder.newLine();
      _builder.append("\t\t\t    ");
      _builder.append("float yc = ISAXRegFile[rs1].vector2d.y_coord;");
      _builder.newLine();
      _builder.append("\t\t\t    ");
      _builder.append("double result;");
      _builder.newLine();
      _builder.append("\t\t\t    ");
      _builder.append("double sqdist = xc*xc + yc*yc;");
      _builder.newLine();
      _builder.append("\t\t\t    ");
      _builder.append("if(sqdist==0 || sqdist[30:23]==0xff)");
      _builder.newLine();
      _builder.append("\t\t\t        ");
      _builder.append("result = 0; // avoid special cases");
      _builder.newLine();
      _builder.append("\t\t\t    ");
      _builder.append("else");
      _builder.newLine();
      _builder.append("\t\t\t        ");
      _builder.append("result = sqrt(sqdist);");
      _builder.newLine();
      _builder.append("\t\t\t    ");
      _builder.append("ISAXRegFile[rd].doublePrec = result;");
      _builder.newLine();
      _builder.append("\t\t    ");
      _builder.append("}");
      _builder.newLine();
      _builder.append("\t    ");
      _builder.append("}");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("}");
      _builder.newLine();
      _builder.append("}");
      _builder.newLine();
      final String input = _builder.toString();
      final DescriptionContent content = this.parseHelper.parse(input);
      Assert.assertEquals(1, content.getDefinitions().size());
      final Resource resource = content.eResource();
      EcoreUtil.resolveAll(resource);
      Assert.assertEquals(0, resource.getErrors().size());
      Assert.assertEquals(0, resource.getWarnings().size());
      ISA _get = content.getDefinitions().get(0);
      final InstructionSet instructionSet = ((InstructionSet) _get);
      Assert.assertNotNull(instructionSet);
      Assert.assertEquals("Vec2D", instructionSet.getName());
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  @Test
  public void loadSine() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("InstructionSet RISCVROB {");
      _builder.newLine();
      _builder.append("    ");
      _builder.append("constants {");
      _builder.newLine();
      _builder.append("        ");
      _builder.append("unsigned int NR_JOINTS = 8;");
      _builder.newLine();
      _builder.append("        ");
      _builder.append("unsigned int REGF_DEPTH = 8;");
      _builder.newLine();
      _builder.append("    ");
      _builder.append("}");
      _builder.newLine();
      _builder.append("    ");
      _builder.append("registers{");
      _builder.newLine();
      _builder.append("        ");
      _builder.append("double JointsRegF[REGF_DEPTH][NR_JOINTS]; //8 joints and 8 regs in RegFile");
      _builder.newLine();
      _builder.append("    ");
      _builder.append("}");
      _builder.newLine();
      _builder.append("    ");
      _builder.append("functions {");
      _builder.newLine();
      _builder.append("        ");
      _builder.append("double sin(double angle) {");
      _builder.newLine();
      _builder.append("            ");
      _builder.append("const unsigned int NR_ITERATIONS = 17;");
      _builder.newLine();
      _builder.append("            ");
      _builder.append("const double ARCTAN[NR_ITERATIONS] = { 45,26.565,14.0362,7.125,3.576, 1.78991,0.895,0.447, 0.2238,0.1119,0.0559,0.0279,0.013988,0.006994, 0.003497,0.001749,0.000874};");
      _builder.newLine();
      _builder.append("            ");
      _builder.append("double sin  = 0;");
      _builder.newLine();
      _builder.append("            ");
      _builder.append("double cos  = 0.607238280;");
      _builder.newLine();
      _builder.append("            ");
      _builder.append("int    sign = 1;");
      _builder.newLine();
      _builder.append("            ");
      _builder.append("double pow  = 1;");
      _builder.newLine();
      _builder.append("            ");
      _builder.append("double tcos, tsin;");
      _builder.newLine();
      _builder.append("            ");
      _builder.append("for (int i = 0; i < NR_ITERATIONS; i++) {");
      _builder.newLine();
      _builder.append("                ");
      _builder.append("if (angle >= 0)");
      _builder.newLine();
      _builder.append("                    ");
      _builder.append("sign = 1;");
      _builder.newLine();
      _builder.append("                ");
      _builder.append("else");
      _builder.newLine();
      _builder.append("                    ");
      _builder.append("sign = -1;");
      _builder.newLine();
      _builder.append("                ");
      _builder.append("tcos  = cos - sign * sin * pow;");
      _builder.newLine();
      _builder.append("                ");
      _builder.append("tsin  = sin + sign * cos * pow;");
      _builder.newLine();
      _builder.append("                ");
      _builder.append("angle = angle - sign * ARCTAN[i];");
      _builder.newLine();
      _builder.append("                ");
      _builder.append("pow  *= 0.5;");
      _builder.newLine();
      _builder.append("                ");
      _builder.append("cos   = tcos;");
      _builder.newLine();
      _builder.append("                ");
      _builder.append("sin   = tsin;");
      _builder.newLine();
      _builder.append("            ");
      _builder.append("}");
      _builder.newLine();
      _builder.append("            ");
      _builder.append("return sin;");
      _builder.newLine();
      _builder.append("       ");
      _builder.append("}");
      _builder.newLine();
      _builder.append("    ");
      _builder.append("}");
      _builder.newLine();
      _builder.append("    ");
      _builder.append("instructions {");
      _builder.newLine();
      _builder.append("        ");
      _builder.append("SIMDSIN {  ");
      _builder.newLine();
      _builder.append("            ");
      _builder.append("encoding: b10101 | rd[4:0] | rs1[4:0] ;");
      _builder.newLine();
      _builder.append("            ");
      _builder.append("args_disass:\"{name(rd)}, {name(rs1)}\"; ");
      _builder.newLine();
      _builder.append("            ");
      _builder.append("behavior: {");
      _builder.newLine();
      _builder.append("\t            ");
      _builder.append("unsigned int i;");
      _builder.newLine();
      _builder.append("\t            ");
      _builder.append("// given sufficient hardware area, the HLS tool can unroll this and perform SIMD processing of up to NR_JOINTS computations in parallel");
      _builder.newLine();
      _builder.append("\t            ");
      _builder.append("// if constrained to smaller hardware area, the HLS tool will unroll only partially or even perform the computation sequentially");
      _builder.newLine();
      _builder.append("\t            ");
      _builder.append("for (i=0;i<NR_JOINTS;i++) // 8 joints");
      _builder.newLine();
      _builder.append("\t                ");
      _builder.append("JointsRegF[rd][i] = sin(JointsRegF[rs1][i]);");
      _builder.newLine();
      _builder.append("            ");
      _builder.append("}");
      _builder.newLine();
      _builder.append("        ");
      _builder.append("} // other instructions...");
      _builder.newLine();
      _builder.append("    ");
      _builder.append("}");
      _builder.newLine();
      _builder.append("}");
      _builder.newLine();
      final String input = _builder.toString();
      final DescriptionContent content = this.parseHelper.parse(input);
      Assert.assertEquals(1, content.getDefinitions().size());
      final Resource resource = content.eResource();
      EcoreUtil.resolveAll(resource);
      Assert.assertEquals(0, resource.getErrors().size());
      Assert.assertEquals(0, resource.getWarnings().size());
      ISA _get = content.getDefinitions().get(0);
      final InstructionSet instructionSet = ((InstructionSet) _get);
      Assert.assertNotNull(instructionSet);
      Assert.assertEquals("RISCVROB", instructionSet.getName());
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
}
