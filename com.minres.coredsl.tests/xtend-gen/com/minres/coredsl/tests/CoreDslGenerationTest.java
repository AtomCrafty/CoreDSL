/**
 * generated by Xtext 2.10.0
 */
package com.minres.coredsl.tests;

import com.google.inject.Inject;
import com.minres.coredsl.coreDsl.CoreDef;
import com.minres.coredsl.coreDsl.DescriptionContent;
import com.minres.coredsl.coreDsl.ISA;
import com.minres.coredsl.tests.CoreDslInjectorProvider;
import java.util.Map;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.emf.ecore.util.EcoreUtil;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.generator.GeneratorContext;
import org.eclipse.xtext.generator.IGenerator2;
import org.eclipse.xtext.generator.InMemoryFileSystemAccess;
import org.eclipse.xtext.testing.InjectWith;
import org.eclipse.xtext.testing.XtextRunner;
import org.eclipse.xtext.testing.util.ParseHelper;
import org.eclipse.xtext.util.CancelIndicator;
import org.eclipse.xtext.xbase.lib.Exceptions;
import org.eclipse.xtext.xbase.lib.Functions.Function0;
import org.eclipse.xtext.xbase.lib.InputOutput;
import org.eclipse.xtext.xbase.lib.ObjectExtensions;
import org.eclipse.xtext.xbase.lib.Procedures.Procedure1;
import org.junit.Assert;
import org.junit.Test;
import org.junit.runner.RunWith;

@RunWith(XtextRunner.class)
@InjectWith(CoreDslInjectorProvider.class)
@SuppressWarnings("all")
public class CoreDslGenerationTest {
  @Inject
  private IGenerator2 underTest;
  
  @Inject
  private ParseHelper<DescriptionContent> parseHelper;
  
  private final String isa_rv32i = new Function0<String>() {
    @Override
    public String apply() {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("Core RV32I {");
      _builder.newLine();
      _builder.append("    ");
      _builder.append("constants {");
      _builder.newLine();
      _builder.append("        ");
      _builder.append("XLEN:=32;");
      _builder.newLine();
      _builder.append("    ");
      _builder.append("}");
      _builder.newLine();
      _builder.append("    ");
      _builder.append("address_spaces {");
      _builder.newLine();
      _builder.append("        ");
      _builder.append("MEM[8], CSR[32]");
      _builder.newLine();
      _builder.append("    ");
      _builder.append("}            ");
      _builder.newLine();
      _builder.append("    ");
      _builder.append("registers { ");
      _builder.newLine();
      _builder.append("        ");
      _builder.append("[31:0]   X[XLEN],");
      _builder.newLine();
      _builder.append("                ");
      _builder.append("PC[XLEN](is_pc),");
      _builder.newLine();
      _builder.append("                ");
      _builder.append("mepc[XLEN],");
      _builder.newLine();
      _builder.append("                ");
      _builder.append("mtvec[XLEN]");
      _builder.newLine();
      _builder.append("                ");
      _builder.newLine();
      _builder.append("    ");
      _builder.append("} ");
      _builder.newLine();
      _builder.append("    ");
      _builder.append("instructions { ");
      _builder.newLine();
      _builder.append("        ");
      _builder.append("ADDI {");
      _builder.newLine();
      _builder.append("            ");
      _builder.append("encoding: imm[11:0] :: rs1[4:0] :: b000 :: rd[4:0] :: b0010011;");
      _builder.newLine();
      _builder.append("            ");
      _builder.append("if(rd!=0) X[rd] <= X[rs1] + sext(imm, XLEN);");
      _builder.newLine();
      _builder.append("        ");
      _builder.append("}");
      _builder.newLine();
      _builder.append("        ");
      _builder.append("SLTI {");
      _builder.newLine();
      _builder.append("            ");
      _builder.append("encoding: imm[11:0] :: rs1[4:0] :: b010 :: rd[4:0] :: b0010011;");
      _builder.newLine();
      _builder.append("            ");
      _builder.append("if(rd!=0) X[rd] <= choose(X[rs1]s < sext(imm, XLEN), 1, 0);");
      _builder.newLine();
      _builder.append("        ");
      _builder.append("}");
      _builder.newLine();
      _builder.append("        ");
      _builder.append("SLTIU {");
      _builder.newLine();
      _builder.append("            ");
      _builder.append("encoding: imm[11:0] :: rs1[4:0] :: b011 :: rd[4:0] :: b0010011;");
      _builder.newLine();
      _builder.append("            ");
      _builder.append("if(rd!=0) X[rd] <= choose(X[rs1] < zext(imm, XLEN), 1, 0);");
      _builder.newLine();
      _builder.append("        ");
      _builder.append("}");
      _builder.newLine();
      _builder.append("        ");
      _builder.append("SW {");
      _builder.newLine();
      _builder.append("            ");
      _builder.append("encoding: imm[11:5] :: rs2[4:0] :: rs1[4:0] :: b010 :: imm[4:0] :: b0100011;");
      _builder.newLine();
      _builder.append("            ");
      _builder.append("val offs[32] <= X[rs1]s + sext(imm, XLEN);");
      _builder.newLine();
      _builder.append("            ");
      _builder.append("MEM[offs] <= X[rs2];");
      _builder.newLine();
      _builder.append("        ");
      _builder.append("}");
      _builder.newLine();
      _builder.append("        ");
      _builder.append("JAL(no_cont) {");
      _builder.newLine();
      _builder.append("                ");
      _builder.append("encoding: imm[20:20]s :: imm[10:1]s :: imm[11:11]s :: imm[19:12]s :: rd[4:0] :: b1101111;");
      _builder.newLine();
      _builder.append("                ");
      _builder.append("if(rd!=0) X[rd] <= PC+4;");
      _builder.newLine();
      _builder.append("                ");
      _builder.append("PC<=PC+sext(imm);");
      _builder.newLine();
      _builder.append("        ");
      _builder.append("}");
      _builder.newLine();
      _builder.append("        ");
      _builder.newLine();
      _builder.append("    ");
      _builder.append("}");
      _builder.newLine();
      _builder.append("}");
      _builder.newLine();
      return _builder.toString();
    }
  }.apply();
  
  @Test
  public void generateCpp() {
    try {
      final DescriptionContent content = this.parseHelper.parse(this.isa_rv32i);
      Assert.assertNotNull(content);
      Assert.assertEquals(1, content.getDefinitions().size());
      final Resource resource = content.eResource();
      EcoreUtil.resolveAll(resource);
      Assert.assertEquals(0, resource.getErrors().size());
      Assert.assertEquals(0, resource.getWarnings().size());
      final InMemoryFileSystemAccess fsa = new InMemoryFileSystemAccess();
      Resource _eResource = content.eResource();
      GeneratorContext _generatorContext = new GeneratorContext();
      final Procedure1<GeneratorContext> _function = (GeneratorContext it) -> {
        it.setCancelIndicator(CancelIndicator.NullImpl);
      };
      GeneratorContext _doubleArrow = ObjectExtensions.<GeneratorContext>operator_doubleArrow(_generatorContext, _function);
      this.underTest.doGenerate(_eResource, fsa, _doubleArrow);
      InputOutput.<Map<String, CharSequence>>println(fsa.getTextFiles());
      Assert.assertEquals(3, fsa.getTextFiles().size());
      Assert.assertTrue(fsa.getTextFiles().containsKey(("vm-out" + "sim-rv32i_instr.cc")));
      Assert.assertTrue(fsa.getTextFiles().containsKey(("incl-out" + "rv32i.h")));
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  @Test
  public void expandCppFile() {
    try {
      final DescriptionContent content = this.parseHelper.parse(this.isa_rv32i);
      Assert.assertNotNull(content);
      final Resource resource = content.eResource();
      EcoreUtil.resolveAll(resource);
      Assert.assertEquals(0, resource.getErrors().size());
      Assert.assertEquals(0, resource.getWarnings().size());
      ISA _get = content.getDefinitions().get(0);
      final CoreDef model = ((CoreDef) _get);
      Assert.assertNotNull(model);
      final InMemoryFileSystemAccess fsa = new InMemoryFileSystemAccess();
      final String quote1 = "«";
      final String quote2 = "»";
      String _lowerCase = model.getName().toLowerCase();
      String _plus = ("vm_" + _lowerCase);
      String _plus_1 = (_plus + ".in.cpp");
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("/* ");
      _builder.append(quote1);
      _builder.append("start generated code");
      _builder.append(quote2);
      _builder.append(" */");
      _builder.newLineIfNotEmpty();
      _builder.append("InstructionDesriptor instr_descr[0] = {};");
      _builder.newLine();
      _builder.append("/* ");
      _builder.append(quote1);
      _builder.append("end generated code");
      _builder.append(quote2);
      _builder.append("  */");
      _builder.newLineIfNotEmpty();
      fsa.generateFile(_plus_1, "vm-out", _builder);
      Resource _eResource = model.eResource();
      GeneratorContext _generatorContext = new GeneratorContext();
      final Procedure1<GeneratorContext> _function = (GeneratorContext it) -> {
        it.setCancelIndicator(CancelIndicator.NullImpl);
      };
      GeneratorContext _doubleArrow = ObjectExtensions.<GeneratorContext>operator_doubleArrow(_generatorContext, _function);
      this.underTest.doGenerate(_eResource, fsa, _doubleArrow);
      InputOutput.<Map<String, CharSequence>>println(fsa.getTextFiles());
      Assert.assertEquals(4, fsa.getTextFiles().size());
      Assert.assertTrue(fsa.getTextFiles().containsKey(("vm-out" + "vm_rv32i.cpp")));
      Assert.assertTrue(fsa.getTextFiles().containsKey(("incl-out" + "rv32i.h")));
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
}
