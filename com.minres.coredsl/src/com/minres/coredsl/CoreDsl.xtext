grammar com.minres.coredsl.CoreDsl with org.eclipse.xtext.common.Terminals

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

generate coreDsl "http://www.minres.com/coredsl/CoreDsl"

DescriptionContent: 
	(imports+=Import)*
	definitions+=ISA+
;

Import :
	'import' importURI=STRING
;

ISA: InstructionSet | CoreDef;

InstructionSet :
	'InsructionSet' name=ID ( 'extends' superType=[InstructionSet] )? '{' 
        ('constants'      '{' constants+=ConstantDecl (',' constants+=ConstantDecl)* '}')?
        ('address_spaces' '{' spaces+=AddressSpace    (',' spaces+=AddressSpace)*    '}')?
    	('registers'      '{' regs+=(Register|RegisterFile|RegisterAlias) (',' regs+=(Register|RegisterFile|RegisterAlias))* '}')?
    	('instructions'   '{' (instr+=Instruction)+ '}')?
    '}'
;

CoreDef:
	'Core' name=ID ( 'provides' contributingType+=[InstructionSet] (',' contributingType+=[InstructionSet])*)? '{' 
        ('template' ':' templateName=STRING ';')?
        ('constants'      '{' (constants+=ConstantDef)+ '}')?
        ('address_spaces' '{' spaces+=AddressSpace (',' spaces+=AddressSpace)* '}')?
    	('registers'      '{' regs+=(Register|RegisterFile|RegisterAlias)    (',' regs+=(Register|RegisterFile|RegisterAlias))*    '}')?
    	('instructions'   '{' (instr+=Instruction)+ '}')?
    '}'
;

RangeSpec:
	'[' left=NATURAL ':' right=NATURAL ']'
;

Instruction:
	name=ID ('(' attributes+=InstrAttribute (',' attributes+=InstrAttribute)* ')' )? '{' 
	('encoding' ':' encoding=Encoding ';') & ('args_disass' ':' disass=STRING ';')?
	operation=Operation? '}'
;

Encoding:
	fields+=Field ('|' fields+=Field)*
;

Field: BitValue | BitField;

BitValue:
    name=BVAL
;

BitField:
    name=ID bitRange=RangeSpec ("'"? type=DataType)?
;

Operation:
	statements+=Statement+
;

Statement: Assignment | ConditionalStmt | DirectCode | Procedure;

Assignment:
	(
		{IndexedAssignment}  to=[IndexedVariable|ID] '[' index=Expression ']' |
		{RegisterAssignment} to=[RegisterVariable] |
		{ScalarAssignment}   to=Scalar
	) (bitWidth=BitSizeSpec)? '<=' expression=Expression ';'
;

ConditionalStmt:
	'if' '(' cond=BooleanOrExpr ')' (thenStmts+= Statement| ('{' thenStmts+= Statement+ '}')) 
	(=> 'else' (elseStmts+= Statement| ('{' elseStmts+= Statement+ '}')))?
;

DirectCode:
	'C++' '{' code+=STRING (code+=STRING)* '}'
;

Procedure:
	name=PROCEDURENAME '(' args+=Expression (',' args+=Expression)* ')' ';'
;

Constant: ConstantDef | ConstantDecl;

ConstantDef:
    name=ID  ':=' value=NATURAL ('(' attributes+=ConstAttribute (',' attributes+=ConstAttribute)* ')' )?';'
;

ConstantDecl returns Constant:
    name=ID (constantDefault = ConstantDefault)?
;

ConstantDefault:
	':=' defaultValue=NATURAL
;

Variable: IndexedVariable | ScalarVariable ;

IndexedVariable: AddressSpace | RegisterFile ;

ScalarVariable:   RegisterVariable | Scalar;

RegisterVariable: Register | RegisterAlias;

AddressSpace:
    name=ID  '['  (bitSize=NATURAL|bitSizeConst=[Constant]) ']'
;

RegisterFile:
    (-> range=RangeSpec name=ID) '[' (bitSize=NATURAL|bitSizeConst=[Constant]) ']' ('(' attributes+=RegAttribute (',' attributes+=RegAttribute)* ')' )?
;

Register:
    name=ID '[' (bitSize=NATURAL|bitSizeConst=[Constant]) ']' ('(' attributes+=RegAttribute (',' attributes+=RegAttribute)* ')' )?
;

RegisterAlias:
    'alias' name=ID '[' (bitSize=NATURAL|bitSizeConst=[Constant]) ']' (
    	'(' attributes+=RegAttribute (',' attributes+=RegAttribute)* ')' 
    )? 'is' (original=[Register] | original=[RegisterFile] '[' (index=NumberLiteral |index=ValueRef) ']')
;

Scalar:
	'val' name=ID '['  (bitSize=NATURAL|bitSizeConst=[Constant]) ']' 
;

// dummy rule to add a property
ScalarBase returns Scalar:
	{Scalar} determined?='is_determined'
;

NumberLiteral:
	value=NATURAL
; 

Expression: BooleanOrExpr;

BooleanOrExpr returns Expression:
	BooleanAndExpr ({BooleanExpr.left=current} op='||' right=BooleanAndExpr)*
;

BooleanAndExpr returns Expression:
	BitOrExpr ({BooleanExpr.left=current} op='&&' right=BitOrExpr)*
;

BitOrExpr returns Expression:
	BitXOrExpr ({BitExpr.left=current} op='|' right=BitXOrExpr)*
;

BitXOrExpr returns Expression:
	BitAndExpr ({BitExpr.left=current} op='^' right=BitAndExpr)*
;

BitAndExpr returns Expression:
	EqualityExpr ({BitExpr.left=current} op='&' right=EqualityExpr)*
;

EqualityExpr returns Expression:
	ComparisonExpr ({ComparisonExpr.left=current} op=('=='|'!=') right=ComparisonExpr)*
;

ComparisonExpr returns Expression:
	ShiftExpr ({ComparisonExpr.left=current} op=('<'|'>'|'<='|'>=') right=ShiftExpr)*
;

ShiftExpr returns Expression:
	AdditionExpr ({ShiftExpr.left=current} op=('<<'|'>>') right=AdditionExpr)*
;

AdditionExpr returns Expression:
    MultiplicationExpr ({AdditionExpr.left=current} op=('+' | '-')  right=MultiplicationExpr)*
;

MultiplicationExpr returns Expression:
    UnitaryExpr ({MultiplicationExpr.left=current} op=('*' | '/' | '%') right=UnitaryExpr)*
;

UnitaryExpr returns Expression:
    TypeConv | ({UnitaryExpr} op=('-'|'+'|'~'|'!') expr=UnitaryExpr)
;

TypeConv returns Expression:
    Primary ({TypeConv.expr=current} "'"? type=DataType)?
;
       
Primary returns Expression:
    '(' Expression ')' |
    {Function} name=FUNCTIONNAME '(' (args+=Expression (',' args+=Expression)* )? ')' |
    NumberLiteral |
    ValueRef
;

RValue: Constant | Field;

ValueRef:
	(
			value=[IndexedVariable|ID] '[' index=Expression ']' |
			value=[ScalarVariable|ID] |
			-> value=[RValue] 
	) (bitWidth=BitSizeSpec)?
;

BitSizeSpec:
'{' (value=NATURAL|constant=[Constant]) '}'	
;

enum DataType:
	NONE | UNSIGNED="u" | SIGNED="s" | FLOAT="f" | DOUBLE="d" | QUAD="q" | BOOLEAN='b'
;

enum RegAttribute: PC='is_pc'|  DEL='delete';

enum ConstAttribute: REG_WIDTH='is_reg_with'|  ADDR_WIDTH='is_addr_width';

enum InstrAttribute: NO_CONT='no_cont' | COND='cond' | FLUSH='flush';

terminal PROCEDURENAME:	('raise' | 'leave' | 'wait' | 'dispatch_' ('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'_'|'0'..'9'|'.')*);

terminal FUNCTIONNAME: ('sext' | 'zext' | 'choose' | 'shll' | 'shrl' | 'shra'  | 'fdispatch_' ('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'_'|'0'..'9'|'.')*);

terminal BVAL : 'b'('0'..'9')+;

terminal BOOLEAN returns ecore::EBoolean: 'true' | 'false' ;

terminal NATURAL returns ecore::EBigInteger:
	('0' | '1'..'9' (('_')? '0'..'9')*) | //DECIMAL 
	(('0b' | '0B') '0'..'1' (('_')? '0'..'1')*) | // BINARY
	(('0x'|'0X') ('0'..'9'|'a'..'f'|'A'..'F')  (('_')? ('0'..'9'|'a'..'f'|'A'..'F'))*) | // HEX
	('0' ('_')? '0'..'7' (('_')? '0'..'7')*) // OCT
;

@Override 
terminal INT returns ecore::EInt: 'this one has been deactivated';
    
@Override 
terminal ID : '^'?('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'_'|'0'..'9'|'.')*;
    
@Override
terminal STRING	:	'"' ( '\\' . /* 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' */ | !('\\'|'"') )* '"';
 