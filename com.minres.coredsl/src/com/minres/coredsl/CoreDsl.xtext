grammar com.minres.coredsl.CoreDsl with org.eclipse.xtext.common.Terminals

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

generate coreDsl "http://www.minres.com/coredsl/CoreDsl"

DescriptionContent: 
	(imports+=Import)*
	definitions+=ISA+
;

Import :
	'import' importURI=STRING
;

ISA: 
	InstructionSet | CoreDef
;

InstructionSet :
	'InstructionSet' name=ID ( 'extends' superType=[InstructionSet] )? '{' 
        ('constants'      '{' constants+=ConstantDecl (',' constants+=ConstantDecl)* '}')?
        ('address_spaces' '{' spaces+=AddressSpace    (',' spaces+=AddressSpace)*    '}')?
    	('registers'      '{' regs+=RegisterDef       (',' regs+=RegisterDef)*       '}')?
    	('instructions'   '{' (instr+=Instruction)+ '}')?
    '}'
;

CoreDef:
	'Core' name=ID ( 'provides' contributingType+=[InstructionSet] (',' contributingType+=[InstructionSet])*)? '{' 
        ('template' ':' templateName=STRING ';')?
        ('constants'      '{' (constants+=ConstantDef)+ '}')?
        ('address_spaces' '{' spaces+=AddressSpace (',' spaces+=AddressSpace)* '}')?
    	('registers'      '{' regs+=RegisterDef    (',' regs+=RegisterDef)*    '}')?
    	('instructions'   '{' (instr+=Instruction)+ '}')?
    '}'
;

RangeSpec:
	'[' left=NATURAL ':' right=NATURAL ']'
;

Instruction:
	name=ID ('(' attributes+=InstrAttribute (',' attributes+=InstrAttribute)* ')' )? '{' 
	('encoding' ':' encoding=Encoding ';') & ('args_disass' ':' disass=STRING ';')?
	operation=Operation? '}'
;

Operation:
	statements+=Statement+
;

Encoding:
	fields+=Field ('|' fields+=Field)*
;

Statement:
    Assignment	| ConditionalStmt | DirectCode | Procedure
;

Assignment:
	(
		({IndexedAssignment} to=[IndexedVar] '[' index=[RValue] ']' ("'"? type=DataType)?)  |
		({PlainAssignment} to=[Register] ("'"? type=DataType)?)  |
		({ScalarAssignment} to=Scalar)
	) (bitWidth=BitSizeSpec)? '<=' expression=Expression ';'
;

ConditionalStmt:
	'if' '(' cond=BooleanExpr ')' (thenStmts+= Statement| ('{' thenStmts+= Statement+ '}')) 
	(=> 'else' (elseStmts+= Statement| ('{' elseStmts+= Statement+ '}')))?
;

DirectCode:
	'C++' '{' code+=STRING (code+=STRING)* '}'
;

Procedure:
	name=PROCEDURENAME '(' args+=Expression (',' args+=Expression)* ')' ';'
;

IndexedVar: 
	AddressSpace | RegisterFile
;

RValue:
	FixedVal | Scalar | AddressSpace | RegisterDef
;

FixedVal:
	Field | Constant
;

Field:
    BitValue | BitField
;

BitValue:
    name=BVAL
;

BitField:
    name=ID bitRange=RangeSpec ("'"? type=DataType)?
;

Constant: 
	ConstantDef | ConstantDecl
;

ConstantDef:
    name=ID  ':=' value=NATURAL ('(' attributes+=ConstAttribute (',' attributes+=ConstAttribute)* ')' )?';'
;

ConstantDecl returns Constant:
    name=ID (constantDefault = ConstantDefault)?
;

ConstantDefault:
	':=' defaultValue=NATURAL
;

Scalar:
	'val' name=ID '['  (bitSize=NATURAL|bitSizeConst=[Constant]) ']' 
;

// dummy rule to add a property
ScalarBase returns Scalar:
	{Scalar} determined?='is_determined'
;

AddressSpace:
    name=ID  '['  (bitSize=NATURAL|bitSizeConst=[Constant]) ']'
;

RegisterDef:
	RegisterFile | Register
;

RegisterFile:
    (-> range=RangeSpec name=ID) '[' (bitSize=NATURAL|bitSizeConst=[Constant]) ']' ('(' attributes+=RegAttribute (',' attributes+=RegAttribute)* ')' )?
;

Register:
    name=ID '[' (bitSize=NATURAL|bitSizeConst=[Constant]) ']' ('(' attributes+=RegAttribute (',' attributes+=RegAttribute)* ')' )?
;

Expression: 
	BooleanExpr
;

BooleanExpression returns Expression:
	BitNot ({BooleanExpression.left=current} op=BitOp right=BitNot)*
;

BooleanExpr returns Expression:
    LogicalNot ({BooleanExpr.left=current} op=ComparisonOp right=LogicalNot)*
;

LogicalNot returns Expression:
    BitExpression | ({LogicalNot} '!' expr=LogicalNot)
;

BitExpression returns Expression:
	BitNot ({BitExpression.left=current} op=BitOp right=BitNot)*
;

BitNot returns Expression:
    Addition | ({BitNot} '~' expr=BitNot)
;

Addition returns Expression:
    Multiplication (({Plus.left=current} '+' | {Minus.left=current} '-') right=Multiplication)*
;

Multiplication returns Expression:
    UnitaryMinus ({Multiplication.left=current} op=('*' | '/' | '%') right=UnitaryMinus)*
;

UnitaryMinus returns Expression:
    TypeConv | ({UnitaryMinus} '-' expr=UnitaryMinus)
;

TypeConv returns Expression:
    Primary ({TypeConv.expr=current} "'"? type=DataType)?
;
       
Primary returns Expression:
    '(' Expression ')' |
    {Function} name=FUNCTIONNAME '(' (args+=Expression (',' args+=Expression)* )? ')' |
    {NumberLiteral} value=NATURAL |
    {RValueRef} rValue=[RValue] ('[' index=[RValue] ']')? (bitWidth=BitSizeSpec)?
;

BitSizeSpec:
'{' (value=NATURAL|constant=[Constant]) '}'	
;

enum ComparisonOp:
	GT='>' | LT='<' | GTE='>=' | LTE='<=' | EQ='=='| NEQ='!='
;

enum BitOp:
	OR='|' | AND='&' | XOR='^' | SHL='<<' | SHR='>>' 
;

enum DataType:
	UNSIGNED="u" | SIGNED="s" | FLOAT="f" | DOUBLE="d" | QUAD="q"
;

enum RegAttribute: PC='is_pc'|  DEL='delete';

enum ConstAttribute: REG_WIDTH='is_reg_with'|  ADDR_WIDTH='is_addr_width';

enum InstrAttribute: NO_CONT='no_cont' | COND='cond' | FLUSH='flush';

terminal PROCEDURENAME:	('raise' | 'leave' | 'wait' | 'dispatch_' ('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'_'|'0'..'9'|'.')*);

terminal FUNCTIONNAME: ('sext' | 'zext' | 'choose' | 'shll' | 'shrl' | 'shra'  | 'sqrt' | 'fdispatch_' ('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'_'|'0'..'9'|'.')*);

terminal BVAL : 'b'('0'..'9')+;

terminal BOOLEAN returns ecore::EBoolean: 'true' | 'false' ;

terminal NATURAL returns ecore::ELong:
	('0' | '1'..'9' (('_')? '0'..'9')*) | //DECIMAL 
	(('0b' | '0B') '0'..'1' (('_')? '0'..'1')*) | // BINARY
	(('0x'|'0X') ('0'..'9'|'a'..'f'|'A'..'F')  (('_')? ('0'..'9'|'a'..'f'|'A'..'F'))*) | // HEX
	('0' ('_')? '0'..'7' (('_')? '0'..'7')*) // OCT
;

@Override 
terminal INT returns ecore::EInt: 'this one has been deactivated';
    
@Override 
terminal ID : '^'?('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'_'|'0'..'9'|'.')*;
    
@Override
terminal STRING	:	'"' ( '\\' . /* 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' */ | !('\\'|'"') )* '"';
