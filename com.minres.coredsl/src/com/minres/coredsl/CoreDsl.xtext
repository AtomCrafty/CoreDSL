grammar com.minres.coredsl.CoreDsl with org.eclipse.xtext.common.Terminals

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

generate coreDsl "http://www.minres.com/coredsl/CoreDsl/2.0"

DescriptionContent
	: (imports+=Import)* definitions+=ISA+ 
	;

Import
	: 'import' importURI=STRING
	;

ISA
	: InstructionSet
	| CoreDef
	;

InstructionSet :
	'InstructionSet' name=ID ( 'extends' superType=[InstructionSet] )? '{' 
        ('constants'      '{' constants+=Declaration+   '}')?
        ('address_spaces' '{' spaces+=Declaration+      '}')?
    	('registers'      '{' regs+=Declaration+        '}')?
    	('functions'      '{' func+=FunctionDefinition+ '}')?
    	('instructions'   '{' (instr+=Instruction)+     '}')
    '}'
;

CoreDef:
	'Core' name=ID ( 'provides' contributingType+=[InstructionSet] (',' contributingType+=[InstructionSet])*)? '{' 
        ('constants'      '{' constants+=Declaration+   '}')?
        ('address_spaces' '{' spaces+=Declaration+      '}')?
    	('registers'      '{' regs+=Declaration+        '}')?
    	('instructions'   '{' (instr+=Instruction)+     '}')?
    '}'
;

Instruction:
	name=ID ('[[' attributes+=InstrAttribute (',' attributes+=InstrAttribute)* ']]' )? '{' 
		('encoding' ':' encoding=Encoding ';') ('args_disass' ':' disass=STRING ';')? ('behavior' ':' behavior=CompoundStatement)
	'}'
;

Encoding
	:	fields+=Field ('|' fields+=Field)*
	;

Field
	: 	BitValue
	|	BitField
	;

BitValue
	: 	name=BVAL
	;

BitField
	:	name=ID bitRange=RangeSpec ("'"? type=BitfieldDataType)?
	;

RangeSpec
	:	'[' left=NATURAL ':' right=NATURAL ']'
	;

FunctionDefinition
	:   extern?='extern'? type=TypeSpecifier name=ID '(' ParameterList ')' statement=CompoundStatement
	;

fragment ParameterList: params+=ParameterDeclaration (',' parameters+=ParameterDeclaration)*;

ParameterDeclaration
    :   type=TypeSpecifier
    	(	declarator=DirectDeclarator
    	|	declarator=AbstractDeclarator
    	)?
    ;

///////////////////////////////////////////////////////////////////////////////
// Statements
Statement
    :   CompoundStatement
    |   ExpressionStatement
    |   SelectionStatement
    |   IterationStatement
    |   JumpStatement
    ;

LabeledStatement
    :   'case' constExpr=ConstantExpression ':' stmt=Statement
    |   'default' ':' stmt=Statement
    ;

CompoundStatement
    :   {CompoundStatement} '{' items+=BlockItem* '}'
    ;

BlockItem
    :   Statement
    |   Declaration
    ;

ExpressionStatement
    :   {ExpressionStatement} expr=AssignmentExpression? ';'
    ;

SelectionStatement
    :   IfStatement
    |   SwitchStatement
    ;
IfStatement
    :   'if' '(' cond=ConditionalExpression ')' thenStmt=Statement (=> 'else' elseStmt=Statement)?
    ;
SwitchStatement
    :   'switch' '(' cond=ConditionalExpression ')' '{' items+=LabeledStatement '}'
    ;

IterationStatement
    :   type='while' '(' cond=ConditionalExpression ')' stmt=Statement
    |   type='do' stmt=Statement 'while' '(' cond=ConditionalExpression ')' ';'
    |   type='for' '(' ForCondition ')' stmt=Statement
    ;

fragment ForCondition
	:   (startDecl=Declaration | startExpr=Expression? ';') endExpr=ConditionalExpression? ';'  (loopExprs+=AssignmentExpression (',' loopExprs+=AssignmentExpression)*)?
	;

JumpStatement
    :   type='continue' ';'
    |   type='break' ';'
    |   type='return' expr=ConditionalExpression? ';'
    ;


///////////////////////////////////////////////////////////////////////////////
// Declarations

Declaration
	:   TypeOrVarDeclaration
	|   TypedefDeclaration
	;
	
TypeOrVarDeclaration
	:	DeclarationSpecifier* type=TypeSpecifier size=BitSizeSpecifier? (init+=InitDeclarator (',' init+=InitDeclarator)*)? ';'
	;
	
TypedefDeclaration
	:	'typedef' DeclarationSpecifier* type=TypeSpecifier init+=InitDeclarator ';'
	;
	
fragment DeclarationSpecifier
    :   storage+=StorageClassSpecifier
    |   qualifiers+=TypeQualifier
    |   AttributeList
    ;

fragment AttributeList:	'[[' attrs+=Attribute (',' attrs+=Attribute)* ']]';

TypeSpecifier
	:	DataTypeSpecifier
	|	TypedefRef
	;

DataTypeSpecifier
	:	PodSpecifier 
	|	StructOrUnionSpecifier
	|	EnumSpecifier
	;
    
TypedefRef
	:	ref=[DirectDeclarator]
	;
    
PodSpecifier
	:	dataType+=DataTypes+
	;

BitSizeSpecifier
	:	'<' (value=NATURAL|constant=[Constant]) '>'
	;

EnumSpecifier
    :   'enum' name=ID? '{' EnumeratorList ','? '}'
    |   'enum' name=ID
    ;

fragment EnumeratorList:   enumerators+=Enumerator (',' enumerators+=Enumerator)*;

Enumerator
    :   name=ID
    |   name=ID '=' expression=ConstantExpression
    ;

StructOrUnionSpecifier
    :   composeType=StructOrUnion name=ID? '{' (decls += StructDeclaration)* '}'
    |   composeType=StructOrUnion name=ID
    ;

StructDeclaration
    :   specifier=StructDeclarationSpecifier decls += DirectDeclarator(',' decls+=DirectDeclarator)* ';'
    ;

StructDeclarationSpecifier
    :   type=TypeSpecifier
    |   qualifiers+=TypeQualifier
    ;

InitDeclarator
    :   declarator=DirectDeclarator ('=' initializer=Initializer)?
    ;

DirectDeclarator
    :   name=ID ( ':' index=IntegerConstant)? 
    	(  	{DirectDeclarator.left=current} '[' (qualifiers+=TypeQualifier)? expr=ConditionalExpression? ']'
//    	|   {DirectDeclarator.left=current} '[' (qualifiers+=TypeQualifier)? '*' ']'
//    	|   {DirectDeclarator.left=current} '(' ParameterList ')'
    	)?
    ;
    
fragment InitializerList:   init+=(DesignatedInitializer|Initializer) (',' init+=(DesignatedInitializer|Initializer))?;

Initializer
    :   expr=ConditionalExpression
    |   '{' InitializerList ','? '}'
    ;

DesignatedInitializer
	:	(designators+=Designator)+ '=' init=Initializer
	;

Designator
    :   '[' idx=ConstantExpression ']'
    |   '.' prop=ID
    ;

AbstractDeclarator
    :	DirectAbstractDeclarator
    ;
/*
 direct_abstract_declarator
	: '(' abstract_declarator ')'
	| '(' parameter_type_list ')'
	| '(' ')'
	| '[' constant_expression ']'
	| '[' ']'
	| direct_abstract_declarator '[' ']'
	| direct_abstract_declarator '[' constant_expression ']'
	| direct_abstract_declarator '(' ')'
	| direct_abstract_declarator '(' parameter_type_list ')'
	;
 
 */
 
DirectAbstractDeclarator 
    :   {DirectAbstractDeclarator} '(' (declarator=AbstractDeclarator? | ParameterList) ')'
    |	{DirectAbstractDeclarator} '[' expr=ConstantExpression? ']'
    ;

///////////////////////////////////////////////////////////////////////////////
// Expressions
Expression 
    :   AssignmentExpression ({Expression.left=current} ',' right=AssignmentExpression)?
    ;

AssignmentExpression returns Expression
    :   UnaryExpression {AssignmentExpression.left=current} op=('=' | '*=' | '/=' | '%=' | '+=' | '-=' | '<<=' | '>>=' | '&=' | '^=' | '|=') right=ConditionalExpression
    ;

ConditionalExpression returns Expression
    :   LogicalOrExpression ({ConditionalExpression.cond=current} '?' left=ConditionalExpression ':' right=ConditionalExpression)?
    ;

LogicalOrExpression returns Expression
    :   LogicalAndExpression ({LogicalExpr.left=current} op='||' right=LogicalOrExpression)?
    ;

LogicalAndExpression returns Expression
    :   InclusiveOrExpression ({LogicalExpr.left=current} op='&&' right=LogicalAndExpression)?
    ;

InclusiveOrExpression returns Expression
    :   ExclusiveOrExpression ({LogicalExpr.left=current} op='|' right=InclusiveOrExpression)?
    ;

ExclusiveOrExpression returns Expression
    :   AndExpression ({LogicalExpr.left=current} op='^' right=ExclusiveOrExpression)?
    ;

AndExpression returns Expression
    :   EqualityExpression ({LogicalExpr.left=current} op='&' right=AndExpression)?
    ;

EqualityExpression returns Expression
    :   RelationalExpression ({LogicalExpr.left=current} op=('=='|'!=') right=EqualityExpression)?
    ;

RelationalExpression returns Expression
    :   ShiftExpression ({LogicalExpr.left=current} op=('<'|'>'|'<='|'>=') right=RelationalExpression)?
    ;

ShiftExpression returns Expression
    :   AdditiveExpression ({ArithmeticExpression.left=current} op=('<<'|'>>') right=ShiftExpression)?
    ;

AdditiveExpression returns Expression
    :   MultiplicativeExpression ({ArithmeticExpression.left=current} op=('+'|'-') right=AdditiveExpression)?
    ;

MultiplicativeExpression returns Expression
    :   CastExpression ({ArithmeticExpression.left=current} op=('*' | '/' | '%') right=MultiplicativeExpression)?
    ;

CastExpression
    :   UnaryExpression
    |	'(' type=DataTypeSpecifier ')' left=CastExpression
    ;

UnaryExpression
    :   PostfixExpression
    |   op='++' left=UnaryExpression
    |   op='--' left=UnaryExpression
    |   UnaryOperator left=CastExpression
    |   op='sizeof' '(' (left=PostfixExpression |  type=DataTypeSpecifier ) ')'
//    |   op='_Alignof' '(' type=TypeSpecifier ')'
    ;

fragment UnaryOperator:	op=('&' | '*' | '+' | '-' | '~' | '!');

PostfixExpression
    :   PrimaryExpression ({PostfixExpression.left=current} ops+=PostfixOperator)*
    ;

PostfixOperator
	:  	op='[' args+=ConditionalExpression (':' args+=ConditionalExpression)? ']'
	|  	op='(' (args+=ConditionalExpression (',' args+=ConditionalExpression)*)?')' //function call
	|   op='.' member=[DirectDeclarator]  //member=PostfixExpression
	|   op='->' member=[DirectDeclarator] //member=PostfixExpression
	|   op='++'
	|  	op='--'
	;
	
PrimaryExpression
    :	ref=[VariableRef]
    |   constant=Constant
    |   literal+=StringLiteral+
    |   '(' left=ConditionalExpression ')'
    ;

VariableRef hidden()
	:	FunctionDefinition|DirectDeclarator|Field
	;

StringLiteral
    :   EncodingPrefix? val=STRING
    ;

fragment EncodingPrefix :   prefix= ('u8'|'u'|'U'|'L');

ConstantExpression returns Expression
    :   ConditionalExpression
    ;
///////////////////////////////////////////////////////////////////////////////
// Constants
Constant
    :   IntegerConstant
    |	FloatingConstant
    |   CharacterConstant
    |   BoolConstant
    ;

IntegerConstant
    :   val=NATURAL IntegerSuffix?
    ;
    
FloatingConstant
    :  	val=FLOAT FloatingSuffix?
    ;
    
BoolConstant
    :   val=BOOLEAN
    ;
    
fragment IntegerSuffix
    :   UnsignedSuffix LongSuffix?
    |   UnsignedSuffix LongLongSuffix
    |   LongSuffix UnsignedSuffix?
    |   LongLongSuffix UnsignedSuffix?
    ;

fragment UnsignedSuffix:   unsigned?=('u'|'U');

fragment LongSuffix:   long?=('l'|'L');

fragment LongLongSuffix:   longlong?=('ll' | 'LL');

fragment FloatingSuffix:   f?='f' | l?='l' | f?='F' | f?='L';

CharacterConstant
    :   val=CHARCONST
    |   enc="L" val=CHARCONST
    |   enc="u" val=CHARCONST
    |   enc="U" val=CHARCONST
    ;
///////////////////////////////////////////////////////////////////////////////

enum DataTypes
	: BOOL='bool' | CHAR='char' | SHORT='short' | INT='int' | LONG='long'
	| SIGNED='signed' | UNSIGNED='unsigned'
	| FLOAT='float'	| DOUBLE='double'
	| FRAC='frac' | ACCUM='accum'
	;

enum TypeQualifier: CONST='const' | VOLATILE='volatile';

enum StorageClassSpecifier: EXTERN='extern' | STATIC='static';

enum Attribute: NONE | IS_PC='is_pc'| DEL='delete';
	
enum InstrAttribute: NONE | NO_CONT='no_cont' | COND='cond' | FLUSH='flush';

enum StructOrUnion:   STRUCT='struct'|UNION='union';

enum BitfieldDataType:	UNSIGNED="u" | SIGNED="s"; //| FLOAT="f" | DOUBLE="d" | QUAD="q" | BOOLEAN='b';

terminal BVAL : 'b'('0'..'9')+;

terminal BOOLEAN returns ecore::EBoolean: 'true' | 'false' ;

terminal FLOAT returns ecore::EBigDecimal:  (('0'..'9')+ '.' ('0'..'9')*) (('e' | 'E') ('+' | '-')? ('0'..'9')+)?;

terminal NATURAL returns ecore::EBigInteger: (DECIMALCONSTANT) | (BINARYCONSTANT) | (HEXADECIMALCONSTANT) | (OCTALCONSTANT);

terminal fragment BINARYCONSTANT:	('0b' | '0B') '0'..'1' (('_')? '0'..'1')*;

terminal fragment OCTALCONSTANT:   '0' ('_')? '0'..'7' (('_')? '0'..'7')*;

terminal fragment DECIMALCONSTANT:   '0' | '1'..'9' (('_')? '0'..'9')*;

terminal fragment HEXADECIMALCONSTANT:   ('0x'|'0X') ('0'..'9'|'a'..'f'|'A'..'F')  (('_')? ('0'..'9'|'a'..'f'|'A'..'F'))*;

terminal CHARCONST: "'" ( '\\' . /* 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' */ | !('\\'|"'") )* "'";

@Override 
terminal INT returns ecore::EInt: 'this one has been deactivated';
    
@Override 
terminal ID : '^'?('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'_'|'0'..'9')*;
    
@Override
terminal STRING	:	'"' ( '\\' . /* 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' */ | !('\\'|'"') )* '"';
 