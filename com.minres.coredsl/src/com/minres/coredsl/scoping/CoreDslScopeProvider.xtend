/*
 * generated by Xtext 2.10.0
 */
package com.minres.coredsl.scoping

import com.minres.coredsl.coreDsl.Constant
import com.minres.coredsl.coreDsl.CoreDef
import com.minres.coredsl.coreDsl.ISA
import com.minres.coredsl.coreDsl.Instruction
import com.minres.coredsl.coreDsl.InstructionSet
import com.minres.coredsl.coreDsl.Register
import com.minres.coredsl.coreDsl.Scalar
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EReference
import org.eclipse.xtext.EcoreUtil2
import org.eclipse.xtext.scoping.Scopes
import com.minres.coredsl.coreDsl.ValueRef
import com.minres.coredsl.coreDsl.AddressSpace
import com.minres.coredsl.coreDsl.BitField
import com.minres.coredsl.coreDsl.RegisterFile
import com.minres.coredsl.coreDsl.RegisterAlias
import com.minres.coredsl.coreDsl.IndexedAssignment
import com.minres.coredsl.coreDsl.Variable
import com.minres.coredsl.coreDsl.IndexedVariable
import com.minres.coredsl.coreDsl.ScalarVariable
import com.minres.coredsl.coreDsl.RegisterVariable
import com.minres.coredsl.coreDsl.Operation
import org.eclipse.xtext.scoping.IScope
import com.minres.coredsl.coreDsl.ConditionalStmt
import com.minres.coredsl.coreDsl.Statement
import java.util.List
import com.minres.coredsl.coreDsl.ScalarAssignment

/**
 * This class contains custom scoping description.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 */
class CoreDslScopeProvider extends AbstractCoreDslScopeProvider {
		
    override getScope(EObject context, EReference reference) {
        // We want to define the Scope for the Element's superElement cross-reference
		// println("Context "+context.class + " in " + context.eContainer+", reference " + reference.EReferenceType.name)
		//Context class com.minres.coredsl.coreDsl.impl.IndexedAssignmentImplin com.minres.coredsl.coreDsl.impl.ConditionalStmtImpl@9a3d0f4, reference IndexedVar
		if(reference.EReferenceType.name=="ArrayValue") {
			val isa = context.parentOfType(ISA) as ISA
        	return Scopes.scopeFor(isa.allOfType(AddressSpace) + isa.allOfType(RegisterFile))
    	} else if(reference.EReferenceType.name=="Register") {
		  	val isa = context.parentOfType(ISA) as ISA
		  	val scope = Scopes.scopeFor(isa.allOfType(Register))
		  	return scope
    	} else if(reference.EReferenceType.name=="Constant") {
		  	val isa = context.parentOfType(ISA) as ISA
		  	val scope = Scopes.scopeFor(isa.allOfType(Constant))
		  	return scope
    	} else if(reference.EReferenceType.name=="Scalar") {
		  	val instr = context.parentOfType(Instruction) as Instruction
		  	val scope = Scopes.scopeFor(EcoreUtil2.getAllContentsOfType(instr, Scalar))
		  	return scope
    	} else if((context instanceof ValueRef || context instanceof IndexedAssignment) && reference.EReferenceType.name=="EObject") {
    		// ValueRef references RegisterFile | AddressSpace or Scalar | Register | RegisterAlias | Constant
		  	return context.eContainer.symbolsDefinedBefore(context)
    	} else if(reference.EReferenceType.name=="Variable") {
		  	val isa = context.parentOfType(ISA) as ISA
		  	return Scopes.scopeFor(isa.allOfType(Variable))
    	} else if(reference.EReferenceType.name=="IndexedVariable") {
		  	val isa = context.parentOfType(ISA) as ISA
		  	return Scopes.scopeFor(isa.allOfType(IndexedVariable))
    	} else if(reference.EReferenceType.name=="ScalarVariable") {
		  	val isa = context.parentOfType(ISA) as ISA
		  	return Scopes.scopeFor(isa.allOfType(ScalarVariable))
    	} else if(context instanceof RegisterAlias && reference.EReferenceType.name=="RegisterDef") {
		  	val isa = context.parentOfType(ISA) as ISA
		  	return Scopes.scopeFor(isa.allOfType(Register)+isa.allOfType(RegisterFile))
		} else {
			//println("Unmatched: context "+context.class + " in " + context.eContainer+", reference " + reference.EReferenceType.name)
	        return super.getScope(context, reference);
		}
    }

	def dispatch IScope symbolsDefinedBefore(EObject cont, EObject o){
		cont.eContainer.symbolsDefinedBefore(o.eContainer)
	}

	def dispatch IScope symbolsDefinedBefore(ConditionalStmt stmt, EObject o){
		if(stmt.cond === o){
			return stmt.eContainer.symbolsDefinedBefore(o.eContainer)
		} else	if(stmt.thenStmts.contains(o)){
			return Scopes.scopeFor(
				stmt.thenStmts.localsDefinedBefore(o),
		  		stmt.eContainer.symbolsDefinedBefore(o.eContainer)
	  		)			
		} else if(stmt.elseStmts.size>0){
			return Scopes.scopeFor(
				stmt.elseStmts.localsDefinedBefore(o),
		  		stmt.eContainer.symbolsDefinedBefore(o.eContainer)
	  		)			
		}
	}

	def dispatch IScope symbolsDefinedBefore(Operation oper, EObject o){
	  	val isa = oper.parentOfType(ISA) as ISA
	  	val inst = oper.eContainer as Instruction
		Scopes.scopeFor(
			oper.statements.localsDefinedBefore(o).toList +
			isa.allOfType(IndexedVariable).toList + 
	  		isa.allOfType(RegisterVariable).toList + 
	  		isa.allOfType(Constant).toList + EcoreUtil2.getAllContentsOfType(inst, BitField)
  		)
	}

	def private localsDefinedBefore(List<Statement> list, EObject o){
		val idx = list.indexOf(o)
		return list.subList(0, idx).filter(typeof(ScalarAssignment)).map[ScalarAssignment a| a.to]
	}
	
	def <T extends EObject> T parentOfType(EObject obj, Class<T> clazz){
		if(obj.eContainer===null)
			return null
		if(clazz.isInstance(obj.eContainer))
			return obj.eContainer as T
		return obj.eContainer.parentOfType(clazz)
	}
	
	def <T extends EObject> T childOfparentOfType(EObject obj, Class<T> clazz){
		if(obj.eContainer===null)
			return null
		if(clazz.isInstance(obj.eContainer))
			return obj as T
		return obj.eContainer.childOfparentOfType(clazz)
	}
	
	def <T extends EObject> Iterable<T> allOfType(ISA isa, Class<T> clazz){
		if(isa.eIsProxy) 
			EcoreUtil2.resolveAll(isa)		
		switch(isa){
			CoreDef:{
				if(isa.contributingType === null)
					return EcoreUtil2.getAllContentsOfType(isa, clazz)
				else
					return EcoreUtil2.getAllContentsOfType(isa, clazz) +  isa.contributingType.map[it.allOfType(clazz)].flatten
			}
			InstructionSet: {
				if(isa.superType === null)
					return EcoreUtil2.getAllContentsOfType(isa, clazz)
				else {
					return EcoreUtil2.getAllContentsOfType(isa, clazz) +  isa.superType.allOfType(clazz)				
				}
			}
		}
	}

}
