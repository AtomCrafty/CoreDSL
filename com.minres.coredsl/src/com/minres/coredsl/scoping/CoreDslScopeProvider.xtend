/*
 * generated by Xtext 2.10.0
 */
package com.minres.coredsl.scoping

import com.minres.coredsl.coreDsl.CoreDef
import com.minres.coredsl.coreDsl.DirectDeclarator
import com.minres.coredsl.coreDsl.ISA
import com.minres.coredsl.coreDsl.InstructionSet
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EReference
import org.eclipse.xtext.EcoreUtil2
import org.eclipse.xtext.scoping.Scopes
import com.minres.coredsl.coreDsl.Variable
import com.minres.coredsl.coreDsl.Instruction
import com.minres.coredsl.coreDsl.CoreDslPackage
import com.minres.coredsl.coreDsl.Declaration
import org.eclipse.emf.common.util.EList
import com.google.common.collect.Lists
import com.minres.coredsl.coreDsl.FunctionDefinition
import java.util.Iterator
import com.google.common.collect.Iterators
import com.google.common.collect.Iterables

/**
 * This class contains custom scoping description.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 */
class CoreDslScopeProvider extends AbstractCoreDslScopeProvider {
		
    override getScope(EObject context, EReference reference) {
        // We want to define the Scope for the Element's superElement cross-reference
		// println("Context "+context.class + " in " + context.eContainer+", reference " + reference.EReferenceType.name)
		//Context class com.minres.coredsl.coreDsl.impl.IndexedAssignmentImplin com.minres.coredsl.coreDsl.impl.ConditionalStmtImpl@9a3d0f4, reference IndexedVar
		if(reference.EReferenceType==CoreDslPackage.Literals.VARIABLE) {
			val isa = context.parentOfType(ISA) as ISA
			val instr = context.parentOfType(Instruction) as Instruction
			if(instr !== null)
	        	return Scopes.scopeFor(EcoreUtil2.getAllContentsOfType(instr, Variable), Scopes.scopeFor(isa.allOfType(Variable)))
			else			
        		return Scopes.scopeFor(isa.allOfType(Variable))
        } else if(reference.EReferenceType==CoreDslPackage.Literals.INSTRUCTION_SET) {
            return super.getScope(context, reference);
        } else if(reference.EReferenceType.name==CoreDslPackage.Literals.CORE_DEF) {
            return super.getScope(context, reference);
		} else {
			println("Unmatched: context "+context.class + " in " + context.eContainer+", reference " + reference.EReferenceType.name)
	        return super.getScope(context, reference);
		}
    }

	def <T extends EObject> T parentOfType(EObject obj, Class<T> clazz){
		if(obj.eContainer===null)
			return null
		if(clazz.isInstance(obj.eContainer))
			return obj.eContainer as T
		return obj.eContainer.parentOfType(clazz)
	}
	
	def <T extends EObject> T childOfparentOfType(EObject obj, Class<T> clazz){
		if(obj.eContainer===null)
			return null
		if(clazz.isInstance(obj.eContainer))
			return obj as T
		return obj.eContainer.childOfparentOfType(clazz)
	}
	
	def <T extends EObject> Iterable<T> allOfType(ISA isa, Class<T> clazz){
		if(isa.eIsProxy) 
			EcoreUtil2.resolveAll(isa)		
		switch(isa){
			CoreDef:{
				val ret = isa.regs.allOfType(clazz) + isa.constants.allOfType(clazz) + isa.spaces.allOfType(clazz)
				if(isa.contributingType === null)
					return ret
				else
					return ret +  isa.contributingType.map[it.allOfType(clazz)].flatten
			}
			InstructionSet: {
				val ret = isa.regs.allOfType(clazz) + isa.constants.allOfType(clazz) + isa.spaces.allOfType(clazz) + isa.func as Iterable<T>
				if(isa.superType === null)
					return ret
				else {
					return ret +  isa.superType.allOfType(clazz)				
				}
			}
		}
	}
	
	def <T extends EObject> Iterable<T> allOfType(EList<Declaration> decls, Class<T> clazz){
		decls.map[EcoreUtil2.getAllContentsOfType(it, clazz)].flatten
	}
}
