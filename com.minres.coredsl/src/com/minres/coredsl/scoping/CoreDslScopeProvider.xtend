/*
 * generated by Xtext 2.10.0
 */
package com.minres.coredsl.scoping

import com.minres.coredsl.coreDsl.CoreDef
import com.minres.coredsl.coreDsl.DirectDeclarator
import com.minres.coredsl.coreDsl.ISA
import com.minres.coredsl.coreDsl.InstructionSet
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EReference
import org.eclipse.xtext.EcoreUtil2
import org.eclipse.xtext.scoping.Scopes
import com.minres.coredsl.coreDsl.Variable

/**
 * This class contains custom scoping description.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 */
class CoreDslScopeProvider extends AbstractCoreDslScopeProvider {
		
    override getScope(EObject context, EReference reference) {
        // We want to define the Scope for the Element's superElement cross-reference
		// println("Context "+context.class + " in " + context.eContainer+", reference " + reference.EReferenceType.name)
		//Context class com.minres.coredsl.coreDsl.impl.IndexedAssignmentImplin com.minres.coredsl.coreDsl.impl.ConditionalStmtImpl@9a3d0f4, reference IndexedVar
		if(reference.EReferenceType.name=="Variable") {
			val isa = context.parentOfType(ISA) as ISA
        	return Scopes.scopeFor(isa.allOfType(Variable))
    	} else if(reference.EReferenceType.name=="DirectDeclarator") {
		  	val isa = context.parentOfType(ISA) as ISA
		  	return Scopes.scopeFor(isa.allOfType(DirectDeclarator))
        } else if(reference.EReferenceType.name=="InstructionSet") {
            return super.getScope(context, reference);
        } else if(reference.EReferenceType.name=="CoreDef") {
            return super.getScope(context, reference);
		} else {
			println("Unmatched: context "+context.class + " in " + context.eContainer+", reference " + reference.EReferenceType.name)
	        return super.getScope(context, reference);
		}
    }

	def <T extends EObject> T parentOfType(EObject obj, Class<T> clazz){
		if(obj.eContainer===null)
			return null
		if(clazz.isInstance(obj.eContainer))
			return obj.eContainer as T
		return obj.eContainer.parentOfType(clazz)
	}
	
	def <T extends EObject> T childOfparentOfType(EObject obj, Class<T> clazz){
		if(obj.eContainer===null)
			return null
		if(clazz.isInstance(obj.eContainer))
			return obj as T
		return obj.eContainer.childOfparentOfType(clazz)
	}
	
	def <T extends EObject> Iterable<T> allOfType(ISA isa, Class<T> clazz){
		if(isa.eIsProxy) 
			EcoreUtil2.resolveAll(isa)		
		switch(isa){
			CoreDef:{
				if(isa.contributingType === null)
					return EcoreUtil2.getAllContentsOfType(isa, clazz)
				else
					return EcoreUtil2.getAllContentsOfType(isa, clazz) +  isa.contributingType.map[it.allOfType(clazz)].flatten
			}
			InstructionSet: {
				if(isa.superType === null)
					return EcoreUtil2.getAllContentsOfType(isa, clazz)
				else {
					return EcoreUtil2.getAllContentsOfType(isa, clazz) +  isa.superType.allOfType(clazz)				
				}
			}
		}
	}
}
