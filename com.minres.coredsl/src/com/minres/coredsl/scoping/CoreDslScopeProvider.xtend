/*
 * generated by Xtext 2.10.0
 */
package com.minres.coredsl.scoping

import com.minres.coredsl.coreDsl.BitField
import com.minres.coredsl.coreDsl.BlockItem
import com.minres.coredsl.coreDsl.CompoundStatement
import com.minres.coredsl.coreDsl.CoreDef
import com.minres.coredsl.coreDsl.CoreDslPackage
import com.minres.coredsl.coreDsl.DirectDeclarator
import com.minres.coredsl.coreDsl.FunctionDefinition
import com.minres.coredsl.coreDsl.ISA
import com.minres.coredsl.coreDsl.Instruction
import com.minres.coredsl.coreDsl.InstructionSet
import com.minres.coredsl.coreDsl.IterationStatement
import com.minres.coredsl.coreDsl.SelectionStatement
import com.minres.coredsl.coreDsl.Variable
import java.util.ArrayList
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EReference
import org.eclipse.xtext.EcoreUtil2
import org.eclipse.xtext.scoping.IScope
import org.eclipse.xtext.scoping.Scopes

import static extension com.minres.coredsl.util.ModelUtil.*

/**
 * This class contains custom scoping description.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 */
class CoreDslScopeProvider extends AbstractCoreDslScopeProvider {

	override getScope(EObject context, EReference reference) {
		val scope = switch (reference.EReferenceType) {
			case CoreDslPackage.Literals.VARIABLE:
				// every variable reference is either contained in a Statement or Declaration
				localScope(context.parentOfType(BlockItem) as BlockItem)

			case CoreDslPackage.Literals.DIRECT_DECLARATOR:
				// references to struct and union members
				IScope.NULLSCOPE // TODO: implement!

			case CoreDslPackage.Literals.INSTRUCTION_SET,
			case CoreDslPackage.Literals.CORE_DEF:
				// instruction sets and core definitions are in the global scope, which is handled by Xtext
				super.getScope(context, reference)

			default: {
				println("Unmatched: context " + context.class + " in " + context.eContainer + ", reference " +
					reference.EReferenceType.name)
				IScope.NULLSCOPE
			}
		}
		// println(scope)
		return scope
	}

	def IScope localScope(BlockItem stmtOrDecl) {
		return switch (parent : stmtOrDecl.eContainer) {
			CompoundStatement: {
				val idx = parent.items.indexOf(stmtOrDecl)
				val sl = parent.items.subList(0, idx)
				val decls = sl.flatMap[x|EcoreUtil2.getAllContentsOfType(x, DirectDeclarator)]
				Scopes.scopeFor(decls, localScope(parent))
			}
			SelectionStatement:
				localScope(parent)
			IterationStatement:
				Scopes.scopeFor(EcoreUtil2.getAllContentsOfType(parent, DirectDeclarator), localScope(parent))
			
			Instruction:
				Scopes.scopeFor(EcoreUtil2.getAllContentsOfType(parent, BitField),
					globalScope(parent.parentOfType(ISA) as ISA))
			FunctionDefinition:
				Scopes.scopeFor(EcoreUtil2.getAllContentsOfType(parent, DirectDeclarator),
					globalScope(parent.parentOfType(ISA) as ISA))
			ISA:
				globalScope(parent)
			
			default:
				IScope.NULLSCOPE
		}
	}

	def IScope globalScope(ISA isa) {
		val decls = new ArrayList<Variable>()
		for (component : #[isa.constants, isa.regs, isa.spaces]) {
			if (component !== null)
				// be careful here to only add top-level declarators, i.e. _NOT_ struct-members etc.
				decls.addAll(component.flatMap[init].flatMap[i|EcoreUtil2.getAllContentsOfType(i, DirectDeclarator)])
		}
		if (isa.func !== null)
			decls.addAll(isa.func)

		val outerScope = if (isa instanceof InstructionSet) {
				if (isa.superType !== null)
					globalScope(isa.superType)
				else
					IScope.NULLSCOPE
			} else if (isa instanceof CoreDef) {
				// TODO: not sure yet how to handle the contributingTypes here
				IScope.NULLSCOPE
			}
		return Scopes.scopeFor(decls, outerScope)
	}
}
