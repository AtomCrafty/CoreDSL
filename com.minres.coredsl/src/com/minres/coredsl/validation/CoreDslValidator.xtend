/*
 * generated by Xtext 2.10.0
 */
package com.minres.coredsl.validation

import com.minres.coredsl.coreDsl.CastExpression
import com.minres.coredsl.coreDsl.CoreDslPackage
import com.minres.coredsl.coreDsl.Expression
import com.minres.coredsl.coreDsl.InfixExpression
import com.minres.coredsl.coreDsl.PostfixExpression
import com.minres.coredsl.coreDsl.PrefixExpression
import com.minres.coredsl.coreDsl.PrimaryExpression
import com.minres.coredsl.coreDsl.PrimitiveType
import com.minres.coredsl.coreDsl.TypeSpecifier
import com.minres.coredsl.typing.DataType

import static extension com.minres.coredsl.typing.TypeProvider.*
import org.eclipse.xtext.validation.Check
import com.minres.coredsl.coreDsl.ISA
import com.minres.coredsl.coreDsl.Attribute
import com.minres.coredsl.coreDsl.Instruction
import com.minres.coredsl.coreDsl.InitDeclarator
import com.minres.coredsl.coreDsl.Declaration
import com.minres.coredsl.coreDsl.FunctionDefinition

/**
 * This class contains custom validation rules. 
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class CoreDslValidator extends AbstractCoreDslValidator {

	/*TODO: 
	 * * check for cycles in structs
	 * * check for member selection
	 * * check for return statements
	 * * check for duplicate fields
	 * 
	 */
	protected static val ISSUE_CODE_PREFIX = "com.minres.coredsl."
	public static val TYPE_MISMATCH = ISSUE_CODE_PREFIX + "TypeMismatch"
	public static val TYPE_ILLEGAL = ISSUE_CODE_PREFIX + "TypeIllegal"
	public static val ILLEGAL_ATTRIBUTE = ISSUE_CODE_PREFIX + "IllegalAttribute"
	public static val INVALID_ATTRIBUTE_PARAMETERS = ISSUE_CODE_PREFIX + "InvalidAttributeParameters"

	// @Check
	def checkType(Expression e) {
		switch (e) {
			case PrimaryExpression,
			case PostfixExpression,
			case PrefixExpression:
				if (e.typeFor === null)
					error(
						"incompatible types used",
						CoreDslPackage.Literals.EXPRESSION__EXPRESSIONS,
						TYPE_MISMATCH
					)
			case CastExpression: {
				if ((e as CastExpression).type.typeFor === null)
					error(
						"illegal type used",
						CoreDslPackage.Literals.CAST_EXPRESSION__TYPE,
						TYPE_ILLEGAL
					)
			}
			case InfixExpression: {
				val infix = e as InfixExpression
				switch (infix.op) {
					case '<',
					case '>',
					case '<=',
					case '>=',
					case '==',
					case '!=':
						if (!e.left.typeFor.isComparable((e as InfixExpression).right.typeFor))
							error(
								"incompatible types used",
								CoreDslPackage.Literals.EXPRESSION__EXPRESSIONS,
								TYPE_MISMATCH
							)
					case '||',
					case '&&',
					case '<<',
					case '>>',
					case '+',
					case '-',
					case '*',
					case '/',
					case '%',
					case '|',
					case '^',
					case '&':
						if (!e.left.typeFor.isComputable((e as InfixExpression).right.typeFor))
							error(
								"incompatible types used",
								CoreDslPackage.Literals.EXPRESSION__EXPRESSIONS,
								TYPE_MISMATCH
							)
					default: {
					} // '::'
				}
			}
//            case ConditionalExpression: {
//            }
//            case AssignmentExpression: {
//            }
		}
	}

	// @Check
	def checkType(TypeSpecifier e) {
		switch (e) {
//            case CompositeType: {
//            }
//            case EnumType: {
//            }
			case PrimitiveType: {
				if (e.typeFor === new DataType(DataType.Type.COMPOSITE, 0))
					error(
						"incompatible types used",
						CoreDslPackage.Literals.PRIMITIVE_TYPE__DATA_TYPE,
						TYPE_MISMATCH
					)
			}
		}
	}

	@Check
	def checkAttributeNames(ISA isa) {
		for (Attribute a : isa.attributes) {
			switch (a.type) {
    			case "enable": {
    				if(a.params.size() !== 1)
						error(
							"enable attribute requires exactly one parameter",
							CoreDslPackage.Literals.ISA__ATTRIBUTES,
							INVALID_ATTRIBUTE_PARAMETERS
						)
				}
				case "hls":
					return
				default:
					error(
						"illegal attribute name",
						CoreDslPackage.Literals.ISA__ATTRIBUTES,
						ILLEGAL_ATTRIBUTE
					)
			}
		}

	}

	@Check
	def checkAttributeNames(Instruction instr) {
		for (Attribute a : instr.attributes) {
			switch (a.type) {
    			case "no_cont",
    			case "cond",
    			case "hls",
    			case "flush":
					return
				default:
					error(
						"illegal attribute name",
						CoreDslPackage.Literals.INSTRUCTION__ATTRIBUTES,
						ILLEGAL_ATTRIBUTE
					)
			}
		}

	}

	@Check
	def checkAttributeNames(Declaration decl) {
		for (Attribute a : decl.attributes) {
			switch (a.type) {
    			case "is_pc",
    			case "is_interlock_for":
					return
				default:
					error(
						"illegal attribute name",
						CoreDslPackage.Literals.INIT_DECLARATOR__ATTRIBUTES,
						ILLEGAL_ATTRIBUTE
					)
			}
		}

	}

	@Check
	def checkAttributeNames(InitDeclarator decl) {
		for (Attribute a : decl.attributes) {
			switch (a.type) {
    			case "is_pc",
    			case "is_interlock_for":
					return
				default:
					error(
						"illegal attribute name",
						CoreDslPackage.Literals.INIT_DECLARATOR__ATTRIBUTES,
						ILLEGAL_ATTRIBUTE
					)
			}
		}

	}

	@Check
	def checkAttributeNames(FunctionDefinition decl) {
		for (Attribute a : decl.attributes) {
			switch (a.type) {
    			case "do_not_synthesize":
					return
				default:
					error(
						"illegal attribute name",
						CoreDslPackage.Literals.FUNCTION_DEFINITION__ATTRIBUTES,
						ILLEGAL_ATTRIBUTE
					)
			}
		}

	}
}
