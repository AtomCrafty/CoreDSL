/*
 * generated by Xtext 2.10.0
 */
package com.minres.coredsl.validation

import com.minres.coredsl.coreDsl.CastExpression
import com.minres.coredsl.coreDsl.CoreDslPackage
import com.minres.coredsl.coreDsl.Expression
import com.minres.coredsl.coreDsl.InfixExpression
import com.minres.coredsl.coreDsl.PostfixExpression
import com.minres.coredsl.coreDsl.PrefixExpression
import com.minres.coredsl.coreDsl.PrimaryExpression
import com.minres.coredsl.coreDsl.PrimitiveType
import com.minres.coredsl.coreDsl.TypeSpecifier
import com.minres.coredsl.typing.DataType

import static extension com.minres.coredsl.typing.TypeProvider.*
import org.eclipse.xtext.validation.Check
import com.minres.coredsl.coreDsl.ISA
import com.minres.coredsl.coreDsl.Attribute
import com.minres.coredsl.coreDsl.Instruction
import com.minres.coredsl.coreDsl.InitDeclarator
import com.minres.coredsl.coreDsl.Declaration

/**
 * This class contains custom validation rules. 
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class CoreDslValidator extends AbstractCoreDslValidator {

    /*TODO: 
     * * check for cycles in structs
     * * check for member selection
     * * check for return statements
     * * check for duplicate fields
     * 
     */
    protected static val ISSUE_CODE_PREFIX = "com.minres.coredsl."
    public static val TYPE_MISMATCH = ISSUE_CODE_PREFIX + "TypeMismatch"
    public static val TYPE_ILLEGAL = ISSUE_CODE_PREFIX + "TypeIllegal"
	
    //@Check
    def checkType(Expression e) {
        switch (e) {
            case PrimaryExpression,
            case PostfixExpression,
            case PrefixExpression:
                if (e.typeFor === null)
                    error(
                        "incompatible types used",
                        CoreDslPackage.Literals.EXPRESSION__EXPRESSIONS,
                        TYPE_MISMATCH
                    )
            case CastExpression: {
                if ((e as CastExpression).type.typeFor === null)
                    error(
                        "illegal type used",
                        CoreDslPackage.Literals.CAST_EXPRESSION__TYPE,
                        TYPE_ILLEGAL
                    )
            }
            case InfixExpression: {
                val infix = e as InfixExpression
                switch (infix.op) {
                    case '<',
                    case '>',
                    case '<=',
                    case '>=',
                    case '==',
                    case '!=':
                        if (!e.left.typeFor.isComparable((e as InfixExpression).right.typeFor))
                            error(
                                "incompatible types used",
                                CoreDslPackage.Literals.EXPRESSION__EXPRESSIONS,
                                TYPE_MISMATCH
                            )
                    case '||',
                    case '&&',
                    case '<<',
                    case '>>',
                    case '+',
                    case '-',
                    case '*',
                    case '/',
                    case '%',
                    case '|',
                    case '^',
                    case '&':
                        if (!e.left.typeFor.isComputable((e as InfixExpression).right.typeFor))
                            error(
                                "incompatible types used",
                                CoreDslPackage.Literals.EXPRESSION__EXPRESSIONS,
                                TYPE_MISMATCH
                            )
                    default: {
                    } // '::'
                }
            }
//            case ConditionalExpression: {
//            }
//            case AssignmentExpression: {
//            }
        }
    }

    //@Check
    def checkType(TypeSpecifier e) {
        switch (e) {
//            case CompositeType: {
//            }
//            case EnumType: {
//            }
            case PrimitiveType: {
                if (e.typeFor === new DataType(0, 0))
                    error(
                        "incompatible types used",
                        CoreDslPackage.Literals.PRIMITIVE_TYPE__DATA_TYPE,
                        TYPE_MISMATCH
                    )
            }
        }
    }
    @Check
    def checkAttributeNames(ISA isa) {
    	for(Attribute a: isa.attributes) {
    		switch(a.type) {
    			case ENABLE: if(a.value===null)
                    error(
                        "enable requires a condition",
                        CoreDslPackage.Literals.ISA__ATTRIBUTES,
                        ISSUE_CODE_PREFIX + "MissingValue"
                    )
    			default:
    			    error(
                        "illegal attribute name",
                        CoreDslPackage.Literals.ISA__ATTRIBUTES,
                        ISSUE_CODE_PREFIX + "IllegalAttribute"
                    )
    		}
    	}
    	
    }
    
    @Check
    def checkAttributeNames(Instruction instr) {
    	for(Attribute a: instr.attributes) {
    		switch(a.type) {
    			case NO_CONT,
    			case COND,
    			case FLUSH:
    				return
    			default:
    			    error(
                        "illegal attribute name",
                        CoreDslPackage.Literals.INSTRUCTION__ATTRIBUTES,
                        ISSUE_CODE_PREFIX + "IllegalAttribute"
                    )
    		}
    	}
    	
    }
    
    @Check
    def checkAttributeNames(Declaration decl) {
    	for(Attribute a: decl.attrs) {
    		switch(a.type) {
    			case IS_PC,
    			case IS_INTERLOCK_FOR:
    				return
    			default:
    			    error(
                        "illegal attribute name",
                        CoreDslPackage.Literals.INIT_DECLARATOR__ATTRS,
                        ISSUE_CODE_PREFIX + "IllegalAttribute"
                    )
    		}
    	}
    	
    }

    @Check
    def checkAttributeNames(InitDeclarator decl) {
    	for(Attribute a: decl.attrs) {
    		switch(a.type) {
    			case IS_PC,
    			case IS_INTERLOCK_FOR:
    				return
    			default:
    			    error(
                        "illegal attribute name",
                        CoreDslPackage.Literals.INIT_DECLARATOR__ATTRS,
                        ISSUE_CODE_PREFIX + "IllegalAttribute"
                    )
    		}
    	}
    	
    }
}
