/*
 * generated by Xtext 2.10.0
 */
package com.minres.coredsl.validation

import com.minres.coredsl.coreDsl.CastExpression
import com.minres.coredsl.coreDsl.CoreDslPackage
import com.minres.coredsl.coreDsl.Expression
import com.minres.coredsl.coreDsl.InfixExpression
import com.minres.coredsl.coreDsl.PostfixExpression
import com.minres.coredsl.coreDsl.PrefixExpression
import com.minres.coredsl.coreDsl.PrimaryExpression

import static extension com.minres.coredsl.typing.TypeProvider.*
import org.eclipse.xtext.validation.Check
import com.minres.coredsl.coreDsl.ISA
import com.minres.coredsl.coreDsl.Attribute
import com.minres.coredsl.coreDsl.Instruction
import com.minres.coredsl.coreDsl.InitDeclarator
import com.minres.coredsl.coreDsl.Declaration
import com.minres.coredsl.coreDsl.FunctionDefinition
import com.minres.coredsl.validation.KnownAttributes.AttributeUsage
import org.eclipse.emf.common.util.EList
import org.eclipse.emf.ecore.EStructuralFeature
import org.eclipse.emf.ecore.EObject
import com.minres.coredsl.coreDsl.IntegerTypeSpecifier
import com.minres.coredsl.coreDsl.FloatTypeSpecifier
import com.minres.coredsl.coreDsl.PointerTypeSpecifier
import com.minres.coredsl.coreDsl.ReferenceTypeSpecifier
import com.minres.coredsl.typing.TypeProvider

/**
 * This class contains custom validation rules. 
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class CoreDslValidator extends AbstractCoreDslValidator {

	/*TODO: 
	 * * check for cycles in structs
	 * * check for member selection
	 * * check for return statements
	 * * check for duplicate fields
	 * 
	 */
	protected static val ISSUE_CODE_PREFIX = "com.minres.coredsl."
	public static val TYPE_MISMATCH = ISSUE_CODE_PREFIX + "TypeMismatch"
	public static val TYPE_ILLEGAL = ISSUE_CODE_PREFIX + "TypeIllegal"
	public static val ILLEGAL_ATTRIBUTE = ISSUE_CODE_PREFIX + "IllegalAttribute"
	public static val INVALID_ATTRIBUTE_PARAMETERS = ISSUE_CODE_PREFIX + "InvalidAttributeParameters"
	public static val UNSUPPORTED_LANGUAGE_FEATURE = ISSUE_CODE_PREFIX + "UnsupportedLanguageFeature"
	
	def error(String message, EObject source, String code, String... issueData) {
		error(message, source, null, -1, code, issueData)
	}

	// @Check
	def checkType(Expression e) {
		switch (e) {
			case PrimaryExpression,
			case PostfixExpression,
			case PrefixExpression:
				if (e.resolveType === null)
					error(
						"incompatible types used",
						CoreDslPackage.Literals.EXPRESSION__EXPRESSIONS,
						TYPE_MISMATCH
					)
					
			case CastExpression: {
				val cast = e as CastExpression
				val fromType = cast.left.resolveType()
				val toType = cast.type.resolveType()
				
				if(!fromType.isExplicitlyConvertibleTo(toType)) {
					error(
						"illegal cast",
						CoreDslPackage.Literals.CAST_EXPRESSION__TYPE,
						TYPE_ILLEGAL
					)
				}
			}
			
			case InfixExpression: {
				val infix = e as InfixExpression
				val leftType = infix.left.resolveType()
				val rightType = infix.right.resolveType()
				
				switch (infix.op) {
					case '<',
					case '>',
					case '<=',
					case '>=',
					case '==',
					case '!=': {
						if (!leftType.isNumeric || !rightType.isNumeric) {
							error(
								"comparison operators are only valid on numeric types",
								CoreDslPackage.Literals.EXPRESSION__EXPRESSIONS,
								TYPE_MISMATCH
							)
						}
					}
							
					case '||',
					case '&&': {
						if (!leftType.isIntegral || !rightType.isIntegral) {
							error(
								"logic operators are only valid on integer types",
								CoreDslPackage.Literals.EXPRESSION__EXPRESSIONS,
								TYPE_MISMATCH
							)
						}
					}
					
					case '<<',
					case '>>',
					case '|',
					case '^',
					case '&': {
						if (!leftType.isIntegral || !rightType.isIntegral) {
							error(
								"bitwise operators are only valid on integer types",
								CoreDslPackage.Literals.EXPRESSION__EXPRESSIONS,
								TYPE_MISMATCH
							)
						}
					}
							
					case '+',
					case '-',
					case '*',
					case '/': {
						if (!leftType.isNumeric || !rightType.isNumeric) {
							error(
								"arithmetic operators are only valid on numeric types",
								CoreDslPackage.Literals.EXPRESSION__EXPRESSIONS,
								TYPE_MISMATCH
							)
						}
					}
					
					case '%': {
						if (!leftType.isIntegral || !rightType.isIntegral) {
							error(
								"the modulo operator is only valid on integer types",
								CoreDslPackage.Literals.EXPRESSION__EXPRESSIONS,
								TYPE_MISMATCH
							)
						}
					}
					
					default: {
					} // '::'
				}
			}
//            case ConditionalExpression: {
//            }
//            case AssignmentExpression: {
//            }
		}
	}

	@Check
	def checkType(IntegerTypeSpecifier typeSpec) {
		// TODO check that the size expression is a positive constant
		typeSpec.resolveType()
	}

	@Check
	def checkType(FloatTypeSpecifier typeSpec) {
		//error("float types are not supported at the moment", typeSpec, UNSUPPORTED_LANGUAGE_FEATURE)
	}
	
	@Check
	def checkType(PointerTypeSpecifier typeSpec) {
		//error("pointer types are not supported at the moment", typeSpec, UNSUPPORTED_LANGUAGE_FEATURE)
	}
	
	@Check
	def checkType(ReferenceTypeSpecifier typeSpec) {
		//error("reference types are not supported at the moment", typeSpec, UNSUPPORTED_LANGUAGE_FEATURE)
	}
	
	def checkAttributes(EObject node, EList<Attribute> attributes, KnownAttributes.AttributeUsage expectedUsage, EStructuralFeature feature) {
		for(Attribute attribute : attributes) {
			val info = KnownAttributes.byName(attribute.type);
			
			if(info === null || !info.allowedUsage.contains(expectedUsage))
				error("unexpected attribute '" + attribute.type + "'", feature, ILLEGAL_ATTRIBUTE);
				
			if(info.validator !== null && !info.validator.validate(node, attribute.params))
				error("unexpected attribute '" + info.name + "'", feature, ILLEGAL_ATTRIBUTE);
			
			if(attribute.params.size() !== info.paramCount)
				error("attribute '" + info.name + "' requires exactly " + info.paramCount + " parameter(s)", feature, INVALID_ATTRIBUTE_PARAMETERS);
		}
	}

	@Check
	def checkAttributeNames(ISA isa) {
		checkAttributes(isa, isa.commonInstructionAttributes, KnownAttributes.AttributeUsage.instruction, CoreDslPackage.Literals.ISA__COMMON_INSTRUCTION_ATTRIBUTES);
	}

	@Check
	def checkAttributeNames(Instruction instr) {
		checkAttributes(instr, instr.attributes, KnownAttributes.AttributeUsage.instruction, CoreDslPackage.Literals.INSTRUCTION__ATTRIBUTES);
	}

	@Check
	def checkAttributeNames(Declaration decl) {
		checkAttributes(decl, decl.attributes, KnownAttributes.AttributeUsage.declaration, CoreDslPackage.Literals.INIT_DECLARATOR__ATTRIBUTES);
	}

	@Check
	def checkAttributeNames(InitDeclarator decl) {
		checkAttributes(decl, decl.attributes, KnownAttributes.AttributeUsage.declaration, CoreDslPackage.Literals.INIT_DECLARATOR__ATTRIBUTES);
	}

	@Check
	def checkAttributeNames(FunctionDefinition func) {
		checkAttributes(func, func.attributes, KnownAttributes.AttributeUsage.function, CoreDslPackage.Literals.FUNCTION_DEFINITION__ATTRIBUTES);
	}
}
