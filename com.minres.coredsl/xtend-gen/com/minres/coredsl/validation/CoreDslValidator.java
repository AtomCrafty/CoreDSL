/**
 * generated by Xtext 2.10.0
 */
package com.minres.coredsl.validation;

import com.google.common.base.Objects;
import com.google.inject.Inject;
import com.minres.coredsl.coreDsl.AdditionExpr;
import com.minres.coredsl.coreDsl.BitExpr;
import com.minres.coredsl.coreDsl.BooleanExpr;
import com.minres.coredsl.coreDsl.ComparisonExpr;
import com.minres.coredsl.coreDsl.CoreDslPackage;
import com.minres.coredsl.coreDsl.DataType;
import com.minres.coredsl.coreDsl.Expression;
import com.minres.coredsl.coreDsl.MultiplicationExpr;
import com.minres.coredsl.coreDsl.RValue;
import com.minres.coredsl.coreDsl.ScalarAssignment;
import com.minres.coredsl.coreDsl.ShiftExpr;
import com.minres.coredsl.coreDsl.TypeConv;
import com.minres.coredsl.coreDsl.UnitaryExpr;
import com.minres.coredsl.coreDsl.ValueRef;
import com.minres.coredsl.coreDsl.Variable;
import com.minres.coredsl.typehandling.ExpressionTypeProvider;
import com.minres.coredsl.typehandling.ExpressionUtilsProvider;
import com.minres.coredsl.validation.AbstractCoreDslValidator;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.xbase.lib.CollectionLiterals;
import org.eclipse.xtext.xbase.lib.Extension;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.eclipse.xtext.xbase.lib.ListExtensions;
import org.eclipse.xtext.xbase.lib.Pair;

/**
 * This class contains custom validation rules.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
@SuppressWarnings("all")
public class CoreDslValidator extends AbstractCoreDslValidator {
  @Inject
  @Extension
  private ExpressionTypeProvider _expressionTypeProvider;
  
  @Inject
  @Extension
  private ExpressionUtilsProvider _expressionUtilsProvider;
  
  protected static final String ISSUE_CODE_PREFIX = "com.minres.coredsl.";
  
  public static final String FORWARD_REFERENCE = (CoreDslValidator.ISSUE_CODE_PREFIX + "ForwardReference");
  
  public static final String TYPE_MISMATCH = (CoreDslValidator.ISSUE_CODE_PREFIX + "TypeMismatch");
  
  public static final String SHADOWING_NAME = (CoreDslValidator.ISSUE_CODE_PREFIX + "NameShadow");
  
  private static final HashMap<DataType, String> typeLookup = CollectionLiterals.<DataType, String>newHashMap(
    Pair.<DataType, String>of(DataType.NONE, "undefined"), 
    Pair.<DataType, String>of(DataType.UNSIGNED, "unsigned"), 
    Pair.<DataType, String>of(DataType.SIGNED, "signed"), 
    Pair.<DataType, String>of(DataType.FLOAT, "float"), 
    Pair.<DataType, String>of(DataType.DOUBLE, "double"), 
    Pair.<DataType, String>of(DataType.QUAD, "quad"), 
    Pair.<DataType, String>of(DataType.BOOLEAN, "bool"));
  
  private final ArrayList<DataType> integerTypes = CollectionLiterals.<DataType>newArrayList(DataType.SIGNED, DataType.UNSIGNED);
  
  private final ArrayList<DataType> arithemeticTypes = CollectionLiterals.<DataType>newArrayList(DataType.SIGNED, DataType.UNSIGNED, DataType.FLOAT, DataType.DOUBLE, DataType.QUAD);
  
  @Check
  public void checkType(final Expression e) {
    boolean _matched = false;
    if (e instanceof BooleanExpr) {
      _matched=true;
      this.checkExpectedType(((BooleanExpr)e).getLeft(), DataType.BOOLEAN, CoreDslPackage.Literals.BOOLEAN_EXPR__LEFT);
      this.checkExpectedType(((BooleanExpr)e).getRight(), DataType.BOOLEAN, CoreDslPackage.Literals.BOOLEAN_EXPR__LEFT);
    }
    if (!_matched) {
      if (e instanceof BitExpr) {
        _matched=true;
        this.checkExpectedSame(this._expressionTypeProvider.typeFor(((BitExpr)e).getLeft()), this._expressionTypeProvider.typeFor(((BitExpr)e).getRight()), CoreDslPackage.Literals.BIT_EXPR);
      }
    }
    if (!_matched) {
      if (e instanceof ComparisonExpr) {
        _matched=true;
        this.checkExpectedSame(this._expressionTypeProvider.typeFor(((ComparisonExpr)e).getLeft()), this._expressionTypeProvider.typeFor(((ComparisonExpr)e).getRight()), CoreDslPackage.Literals.COMPARISON_EXPR);
      }
    }
    if (!_matched) {
      if (e instanceof ShiftExpr) {
        _matched=true;
        this.checkExpectedType(((ShiftExpr)e).getLeft(), this.integerTypes, CoreDslPackage.Literals.SHIFT_EXPR__LEFT);
        this.checkExpectedType(((ShiftExpr)e).getRight(), DataType.UNSIGNED, CoreDslPackage.Literals.SHIFT_EXPR__RIGHT);
      }
    }
    if (!_matched) {
      if (e instanceof AdditionExpr) {
        _matched=true;
        this.checkExpectedType(((AdditionExpr)e).getLeft(), this.arithemeticTypes, CoreDslPackage.Literals.ADDITION_EXPR__LEFT);
        this.checkExpectedType(((AdditionExpr)e).getRight(), this.arithemeticTypes, CoreDslPackage.Literals.ADDITION_EXPR__RIGHT);
        this.checkExpectedSame(this._expressionTypeProvider.typeFor(((AdditionExpr)e).getLeft()), this._expressionTypeProvider.typeFor(((AdditionExpr)e).getRight()), CoreDslPackage.Literals.ADDITION_EXPR);
      }
    }
    if (!_matched) {
      if (e instanceof MultiplicationExpr) {
        _matched=true;
        this.checkExpectedType(((MultiplicationExpr)e).getLeft(), this.arithemeticTypes, CoreDslPackage.Literals.MULTIPLICATION_EXPR__LEFT);
        this.checkExpectedType(((MultiplicationExpr)e).getRight(), this.arithemeticTypes, CoreDslPackage.Literals.MULTIPLICATION_EXPR__RIGHT);
        this.checkExpectedSame(this._expressionTypeProvider.typeFor(((MultiplicationExpr)e).getLeft()), this._expressionTypeProvider.typeFor(((MultiplicationExpr)e).getRight()), CoreDslPackage.Literals.MULTIPLICATION_EXPR);
      }
    }
    if (!_matched) {
      if (e instanceof UnitaryExpr) {
        _matched=true;
        String _op = ((UnitaryExpr)e).getOp();
        boolean _equals = Objects.equal(_op, "!");
        if (_equals) {
          this.checkExpectedType(((UnitaryExpr)e).getExpr(), DataType.BOOLEAN, CoreDslPackage.Literals.UNITARY_EXPR__EXPR);
        } else {
          String _op_1 = ((UnitaryExpr)e).getOp();
          boolean _equals_1 = Objects.equal(_op_1, "~");
          if (_equals_1) {
            this.checkExpectedType(((UnitaryExpr)e).getExpr(), this.integerTypes, CoreDslPackage.Literals.UNITARY_EXPR__EXPR);
          } else {
            this.checkExpectedType(((UnitaryExpr)e).getExpr(), this.arithemeticTypes, CoreDslPackage.Literals.UNITARY_EXPR__EXPR);
          }
        }
      }
    }
    if (!_matched) {
      if (e instanceof TypeConv) {
        _matched=true;
        this.checkExpectedType(((TypeConv)e).getExpr(), this.integerTypes, CoreDslPackage.Literals.TYPE_CONV__EXPR);
      }
    }
  }
  
  @Check
  public void checkDupicateName(final ScalarAssignment e) {
    final List<EObject> symbols = this._expressionUtilsProvider.symbolsDefinedBefore(e, e.getTo());
    final Function1<EObject, Boolean> _function = (EObject it) -> {
      boolean _xifexpression = false;
      if ((it instanceof Variable)) {
        _xifexpression = ((Variable)it).getName().equals(e.getTo().getName());
      } else {
        boolean _xifexpression_1 = false;
        if ((it instanceof RValue)) {
          _xifexpression_1 = ((RValue)it).getName().equals(e.getTo().getName());
        } else {
          _xifexpression_1 = false;
        }
        _xifexpression = _xifexpression_1;
      }
      return Boolean.valueOf(_xifexpression);
    };
    final Iterable<EObject> res = IterableExtensions.<EObject>filter(symbols, _function);
    int _size = IterableExtensions.size(res);
    boolean _greaterThan = (_size > 0);
    if (_greaterThan) {
      String _name = e.getTo().getName();
      String _plus = ("The name \'" + _name);
      String _plus_1 = (_plus + "\' shadows and existing declaration which might lead to gneration issues");
      this.warning(_plus_1, 
        CoreDslPackage.Literals.SCALAR_ASSIGNMENT__TO, 
        CoreDslValidator.SHADOWING_NAME);
    }
  }
  
  @Check
  public void checkForwardReferences(final ValueRef e) {
    final List<EObject> symbols = this._expressionUtilsProvider.symbolsDefinedBefore(e.eContainer(), e);
    final Function1<EObject, Boolean> _function = (EObject it) -> {
      EObject _value = e.getValue();
      return Boolean.valueOf((it == _value));
    };
    final Iterable<EObject> res = IterableExtensions.<EObject>filter(symbols, _function);
    int _size = IterableExtensions.size(res);
    boolean _equals = (_size == 0);
    if (_equals) {
      this.error("Forward references are not allowed", 
        CoreDslPackage.Literals.VALUE_REF__VALUE, 
        CoreDslValidator.FORWARD_REFERENCE);
    }
  }
  
  public void checkExpectedType(final Expression expression, final DataType expectedType, final EReference reference) {
    final DataType actualType = this.getTypeAndCheckNotNull(expression, reference);
    boolean _notEquals = (!Objects.equal(actualType, expectedType));
    if (_notEquals) {
      String _get = CoreDslValidator.typeLookup.get(expectedType);
      String _plus = ("expected type " + _get);
      String _plus_1 = (_plus + ", but but the actual type is ");
      String _get_1 = CoreDslValidator.typeLookup.get(actualType);
      String _plus_2 = (_plus_1 + _get_1);
      this.error(_plus_2, reference, 
        CoreDslValidator.TYPE_MISMATCH);
    }
  }
  
  public void checkExpectedType(final Expression expression, final List<DataType> expectedTypes, final EReference reference) {
    final DataType actualType = this.getTypeAndCheckNotNull(expression, reference);
    final Function1<DataType, Boolean> _function = (DataType it) -> {
      return Boolean.valueOf(Objects.equal(it, actualType));
    };
    boolean _isEmpty = IterableExtensions.isEmpty(IterableExtensions.<DataType>filter(expectedTypes, _function));
    if (_isEmpty) {
      final Function1<DataType, String> _function_1 = (DataType it) -> {
        return CoreDslValidator.typeLookup.get(it);
      };
      String _join = IterableExtensions.join(ListExtensions.<DataType, String>map(expectedTypes, _function_1), ", ");
      String _plus = ("expected a type of [" + _join);
      String _plus_1 = (_plus + "], but the actual type is ");
      String _get = CoreDslValidator.typeLookup.get(actualType);
      String _plus_2 = (_plus_1 + _get);
      this.error(_plus_2, reference, 
        CoreDslValidator.TYPE_MISMATCH);
    }
  }
  
  public void checkExpectedSame(final DataType left, final DataType right, final EClass clazz) {
    if ((((right != null) && (left != null)) && (!Objects.equal(right, left)))) {
      String _get = CoreDslValidator.typeLookup.get(left);
      String _plus = ("expected the same type on both sides, but left is " + _get);
      String _plus_1 = (_plus + " and right is ");
      String _get_1 = CoreDslValidator.typeLookup.get(right);
      String _plus_2 = (_plus_1 + _get_1);
      this.error(_plus_2, clazz.getEIDAttribute(), CoreDslValidator.TYPE_MISMATCH);
    }
  }
  
  private DataType getTypeAndCheckNotNull(final Expression exp, final EReference reference) {
    DataType _typeFor = null;
    if (exp!=null) {
      _typeFor=this._expressionTypeProvider.typeFor(exp);
    }
    final DataType type = _typeFor;
    if ((type == null)) {
      this.error("null type", reference, CoreDslValidator.TYPE_MISMATCH);
    }
    return type;
  }
}
