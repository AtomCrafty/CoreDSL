/*
 * generated by Xtext 2.22.0
 */
package com.minres.coredsl.serializer;

import com.google.inject.Inject;
import com.minres.coredsl.coreDsl.AssignmentExpression;
import com.minres.coredsl.coreDsl.Attribute;
import com.minres.coredsl.coreDsl.BitField;
import com.minres.coredsl.coreDsl.BitSizeSpecifier;
import com.minres.coredsl.coreDsl.BitSizeValue;
import com.minres.coredsl.coreDsl.BitValue;
import com.minres.coredsl.coreDsl.BoolConstant;
import com.minres.coredsl.coreDsl.CastExpression;
import com.minres.coredsl.coreDsl.CharacterConstant;
import com.minres.coredsl.coreDsl.CompoundStatement;
import com.minres.coredsl.coreDsl.ConditionalExpression;
import com.minres.coredsl.coreDsl.CoreDef;
import com.minres.coredsl.coreDsl.CoreDslPackage;
import com.minres.coredsl.coreDsl.DescriptionContent;
import com.minres.coredsl.coreDsl.DesignatedInitializer;
import com.minres.coredsl.coreDsl.Designator;
import com.minres.coredsl.coreDsl.DirectAbstractDeclarator;
import com.minres.coredsl.coreDsl.DirectDeclarator;
import com.minres.coredsl.coreDsl.Encoding;
import com.minres.coredsl.coreDsl.EnumSpecifier;
import com.minres.coredsl.coreDsl.Enumerator;
import com.minres.coredsl.coreDsl.Expression;
import com.minres.coredsl.coreDsl.ExpressionStatement;
import com.minres.coredsl.coreDsl.FloatingConstant;
import com.minres.coredsl.coreDsl.FunctionDefinition;
import com.minres.coredsl.coreDsl.IfStatement;
import com.minres.coredsl.coreDsl.Import;
import com.minres.coredsl.coreDsl.InfixExpression;
import com.minres.coredsl.coreDsl.InitDeclarator;
import com.minres.coredsl.coreDsl.Initializer;
import com.minres.coredsl.coreDsl.Instruction;
import com.minres.coredsl.coreDsl.InstructionSet;
import com.minres.coredsl.coreDsl.IntegerConstant;
import com.minres.coredsl.coreDsl.IterationStatement;
import com.minres.coredsl.coreDsl.JumpStatement;
import com.minres.coredsl.coreDsl.LabeledStatement;
import com.minres.coredsl.coreDsl.ParameterDeclaration;
import com.minres.coredsl.coreDsl.PodSpecifier;
import com.minres.coredsl.coreDsl.PostfixExpression;
import com.minres.coredsl.coreDsl.PostfixOperator;
import com.minres.coredsl.coreDsl.PrefixExpression;
import com.minres.coredsl.coreDsl.PrimaryExpression;
import com.minres.coredsl.coreDsl.RangeSpec;
import com.minres.coredsl.coreDsl.SpawnStatement;
import com.minres.coredsl.coreDsl.StringLiteral;
import com.minres.coredsl.coreDsl.StructDeclaration;
import com.minres.coredsl.coreDsl.StructDeclarationSpecifier;
import com.minres.coredsl.coreDsl.StructOrUnionSpecifier;
import com.minres.coredsl.coreDsl.SwitchStatement;
import com.minres.coredsl.coreDsl.TypeOrVarDeclaration;
import com.minres.coredsl.services.CoreDslGrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class CoreDslSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private CoreDslGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == CoreDslPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case CoreDslPackage.ASSIGNMENT_EXPRESSION:
				if (rule == grammarAccess.getAssignmentExpression2Rule()
						|| action == grammarAccess.getAssignmentExpression2Access().getAssignmentExpressionLeftAction_1_0()) {
					sequence_AssignmentExpression2(context, (AssignmentExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getExpressionRule()
						|| action == grammarAccess.getExpressionAccess().getExpressionLeftAction_1_0()
						|| rule == grammarAccess.getAssignmentExpressionRule()
						|| action == grammarAccess.getAssignmentExpressionAccess().getAssignmentExpressionLeftAction_1_0()) {
					sequence_AssignmentExpression(context, (AssignmentExpression) semanticObject); 
					return; 
				}
				else break;
			case CoreDslPackage.ATTRIBUTE:
				sequence_Attribute(context, (Attribute) semanticObject); 
				return; 
			case CoreDslPackage.BIT_FIELD:
				sequence_BitField(context, (BitField) semanticObject); 
				return; 
			case CoreDslPackage.BIT_SIZE_SPECIFIER:
				sequence_BitSizeSpecifier(context, (BitSizeSpecifier) semanticObject); 
				return; 
			case CoreDslPackage.BIT_SIZE_VALUE:
				sequence_BitSizeValue(context, (BitSizeValue) semanticObject); 
				return; 
			case CoreDslPackage.BIT_VALUE:
				sequence_BitValue(context, (BitValue) semanticObject); 
				return; 
			case CoreDslPackage.BOOL_CONSTANT:
				sequence_BoolConstant(context, (BoolConstant) semanticObject); 
				return; 
			case CoreDslPackage.CAST_EXPRESSION:
				sequence_CastExpression(context, (CastExpression) semanticObject); 
				return; 
			case CoreDslPackage.CHARACTER_CONSTANT:
				sequence_CharacterConstant(context, (CharacterConstant) semanticObject); 
				return; 
			case CoreDslPackage.COMPOUND_STATEMENT:
				sequence_CompoundStatement(context, (CompoundStatement) semanticObject); 
				return; 
			case CoreDslPackage.CONDITIONAL_EXPRESSION:
				sequence_ConditionalExpression(context, (ConditionalExpression) semanticObject); 
				return; 
			case CoreDslPackage.CORE_DEF:
				sequence_CoreDef(context, (CoreDef) semanticObject); 
				return; 
			case CoreDslPackage.DESCRIPTION_CONTENT:
				sequence_DescriptionContent(context, (DescriptionContent) semanticObject); 
				return; 
			case CoreDslPackage.DESIGNATED_INITIALIZER:
				sequence_DesignatedInitializer(context, (DesignatedInitializer) semanticObject); 
				return; 
			case CoreDslPackage.DESIGNATOR:
				sequence_Designator(context, (Designator) semanticObject); 
				return; 
			case CoreDslPackage.DIRECT_ABSTRACT_DECLARATOR:
				sequence_DirectAbstractDeclarator_ParameterList(context, (DirectAbstractDeclarator) semanticObject); 
				return; 
			case CoreDslPackage.DIRECT_DECLARATOR:
				if (action == grammarAccess.getDirectDeclaratorAccess().getDirectDeclaratorLeftAction_2_0_0()
						|| action == grammarAccess.getDirectDeclaratorAccess().getDirectDeclaratorLeftAction_2_1_0()) {
					sequence_DirectDeclarator_DirectDeclarator_2_0_0_DirectDeclarator_2_1_0(context, (DirectDeclarator) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getDirectDeclaratorRule()
						|| rule == grammarAccess.getVariableRefRule()) {
					sequence_DirectDeclarator_ParameterList(context, (DirectDeclarator) semanticObject); 
					return; 
				}
				else break;
			case CoreDslPackage.ENCODING:
				sequence_Encoding(context, (Encoding) semanticObject); 
				return; 
			case CoreDslPackage.ENUM_SPECIFIER:
				sequence_EnumSpecifier_EnumeratorList(context, (EnumSpecifier) semanticObject); 
				return; 
			case CoreDslPackage.ENUMERATOR:
				sequence_Enumerator(context, (Enumerator) semanticObject); 
				return; 
			case CoreDslPackage.EXPRESSION:
				if (rule == grammarAccess.getEmptyExpressionRule()) {
					sequence_EmptyExpression(context, (Expression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getExpressionRule()) {
					sequence_Expression(context, (Expression) semanticObject); 
					return; 
				}
				else break;
			case CoreDslPackage.EXPRESSION_STATEMENT:
				sequence_ExpressionStatement(context, (ExpressionStatement) semanticObject); 
				return; 
			case CoreDslPackage.FLOATING_CONSTANT:
				sequence_FloatingConstant(context, (FloatingConstant) semanticObject); 
				return; 
			case CoreDslPackage.FUNCTION_DEFINITION:
				sequence_FunctionDefinition_ParameterList(context, (FunctionDefinition) semanticObject); 
				return; 
			case CoreDslPackage.IF_STATEMENT:
				sequence_IfStatement(context, (IfStatement) semanticObject); 
				return; 
			case CoreDslPackage.IMPORT:
				sequence_Import(context, (Import) semanticObject); 
				return; 
			case CoreDslPackage.INFIX_EXPRESSION:
				if (rule == grammarAccess.getConditionalExpressionRule()
						|| action == grammarAccess.getConditionalExpressionAccess().getConditionalExpressionCondAction_1_0()
						|| rule == grammarAccess.getConcatenationExpressionRule()
						|| rule == grammarAccess.getConstantExpressionRule()) {
					sequence_AdditiveExpression_AndExpression_ConcatenationExpression_EqualityExpression_ExclusiveOrExpression_InclusiveOrExpression_LogicalAndExpression_LogicalOrExpression_MultiplicativeExpression_RelationalExpression_ShiftExpression(context, (InfixExpression) semanticObject); 
					return; 
				}
				else if (action == grammarAccess.getConcatenationExpressionAccess().getInfixExpressionLeftAction_1_0()
						|| rule == grammarAccess.getLogicalOrExpressionRule()) {
					sequence_AdditiveExpression_AndExpression_EqualityExpression_ExclusiveOrExpression_InclusiveOrExpression_LogicalAndExpression_LogicalOrExpression_MultiplicativeExpression_RelationalExpression_ShiftExpression(context, (InfixExpression) semanticObject); 
					return; 
				}
				else if (action == grammarAccess.getLogicalOrExpressionAccess().getInfixExpressionLeftAction_1_0()
						|| rule == grammarAccess.getLogicalAndExpressionRule()) {
					sequence_AdditiveExpression_AndExpression_EqualityExpression_ExclusiveOrExpression_InclusiveOrExpression_LogicalAndExpression_MultiplicativeExpression_RelationalExpression_ShiftExpression(context, (InfixExpression) semanticObject); 
					return; 
				}
				else if (action == grammarAccess.getLogicalAndExpressionAccess().getInfixExpressionLeftAction_1_0()
						|| rule == grammarAccess.getInclusiveOrExpressionRule()) {
					sequence_AdditiveExpression_AndExpression_EqualityExpression_ExclusiveOrExpression_InclusiveOrExpression_MultiplicativeExpression_RelationalExpression_ShiftExpression(context, (InfixExpression) semanticObject); 
					return; 
				}
				else if (action == grammarAccess.getInclusiveOrExpressionAccess().getInfixExpressionLeftAction_1_0()
						|| rule == grammarAccess.getExclusiveOrExpressionRule()) {
					sequence_AdditiveExpression_AndExpression_EqualityExpression_ExclusiveOrExpression_MultiplicativeExpression_RelationalExpression_ShiftExpression(context, (InfixExpression) semanticObject); 
					return; 
				}
				else if (action == grammarAccess.getExclusiveOrExpressionAccess().getInfixExpressionLeftAction_1_0()
						|| rule == grammarAccess.getAndExpressionRule()) {
					sequence_AdditiveExpression_AndExpression_EqualityExpression_MultiplicativeExpression_RelationalExpression_ShiftExpression(context, (InfixExpression) semanticObject); 
					return; 
				}
				else if (action == grammarAccess.getAndExpressionAccess().getInfixExpressionLeftAction_1_0()
						|| rule == grammarAccess.getEqualityExpressionRule()) {
					sequence_AdditiveExpression_EqualityExpression_MultiplicativeExpression_RelationalExpression_ShiftExpression(context, (InfixExpression) semanticObject); 
					return; 
				}
				else if (action == grammarAccess.getShiftExpressionAccess().getInfixExpressionLeftAction_1_0()
						|| rule == grammarAccess.getAdditiveExpressionRule()) {
					sequence_AdditiveExpression_MultiplicativeExpression(context, (InfixExpression) semanticObject); 
					return; 
				}
				else if (action == grammarAccess.getEqualityExpressionAccess().getInfixExpressionLeftAction_1_0()
						|| rule == grammarAccess.getRelationalExpressionRule()) {
					sequence_AdditiveExpression_MultiplicativeExpression_RelationalExpression_ShiftExpression(context, (InfixExpression) semanticObject); 
					return; 
				}
				else if (action == grammarAccess.getRelationalExpressionAccess().getInfixExpressionLeftAction_1_0()
						|| rule == grammarAccess.getShiftExpressionRule()) {
					sequence_AdditiveExpression_MultiplicativeExpression_ShiftExpression(context, (InfixExpression) semanticObject); 
					return; 
				}
				else if (action == grammarAccess.getAdditiveExpressionAccess().getInfixExpressionLeftAction_1_0()
						|| rule == grammarAccess.getMultiplicativeExpressionRule()) {
					sequence_MultiplicativeExpression(context, (InfixExpression) semanticObject); 
					return; 
				}
				else break;
			case CoreDslPackage.INIT_DECLARATOR:
				sequence_InitDeclarator(context, (InitDeclarator) semanticObject); 
				return; 
			case CoreDslPackage.INITIALIZER:
				sequence_Initializer_InitializerList(context, (Initializer) semanticObject); 
				return; 
			case CoreDslPackage.INSTRUCTION:
				sequence_Instruction(context, (Instruction) semanticObject); 
				return; 
			case CoreDslPackage.INSTRUCTION_SET:
				sequence_InstructionSet(context, (InstructionSet) semanticObject); 
				return; 
			case CoreDslPackage.INTEGER_CONSTANT:
				sequence_IntegerConstant(context, (IntegerConstant) semanticObject); 
				return; 
			case CoreDslPackage.ITERATION_STATEMENT:
				sequence_ForCondition_IterationStatement(context, (IterationStatement) semanticObject); 
				return; 
			case CoreDslPackage.JUMP_STATEMENT:
				sequence_JumpStatement(context, (JumpStatement) semanticObject); 
				return; 
			case CoreDslPackage.LABELED_STATEMENT:
				sequence_LabeledStatement(context, (LabeledStatement) semanticObject); 
				return; 
			case CoreDslPackage.PARAMETER_DECLARATION:
				sequence_ParameterDeclaration(context, (ParameterDeclaration) semanticObject); 
				return; 
			case CoreDslPackage.POD_SPECIFIER:
				sequence_PodSpecifier(context, (PodSpecifier) semanticObject); 
				return; 
			case CoreDslPackage.POSTFIX_EXPRESSION:
				sequence_PostfixExpression(context, (PostfixExpression) semanticObject); 
				return; 
			case CoreDslPackage.POSTFIX_OPERATOR:
				sequence_PostfixOperator(context, (PostfixOperator) semanticObject); 
				return; 
			case CoreDslPackage.PREFIX_EXPRESSION:
				sequence_PrefixExpression_UnaryOperator(context, (PrefixExpression) semanticObject); 
				return; 
			case CoreDslPackage.PRIMARY_EXPRESSION:
				sequence_PrimaryExpression(context, (PrimaryExpression) semanticObject); 
				return; 
			case CoreDslPackage.RANGE_SPEC:
				sequence_RangeSpec(context, (RangeSpec) semanticObject); 
				return; 
			case CoreDslPackage.SPAWN_STATEMENT:
				sequence_SpawnStatement(context, (SpawnStatement) semanticObject); 
				return; 
			case CoreDslPackage.STRING_LITERAL:
				sequence_EncodingPrefix_StringLiteral(context, (StringLiteral) semanticObject); 
				return; 
			case CoreDslPackage.STRUCT_DECLARATION:
				sequence_StructDeclaration(context, (StructDeclaration) semanticObject); 
				return; 
			case CoreDslPackage.STRUCT_DECLARATION_SPECIFIER:
				sequence_StructDeclarationSpecifier(context, (StructDeclarationSpecifier) semanticObject); 
				return; 
			case CoreDslPackage.STRUCT_OR_UNION_SPECIFIER:
				sequence_StructOrUnionSpecifier(context, (StructOrUnionSpecifier) semanticObject); 
				return; 
			case CoreDslPackage.SWITCH_STATEMENT:
				sequence_SwitchStatement(context, (SwitchStatement) semanticObject); 
				return; 
			case CoreDslPackage.TYPE_OR_VAR_DECLARATION:
				sequence_DeclarationSpecifier_TypeOrVarDeclaration(context, (TypeOrVarDeclaration) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     ConditionalExpression returns InfixExpression
	 *     ConditionalExpression.ConditionalExpression_1_0 returns InfixExpression
	 *     ConcatenationExpression returns InfixExpression
	 *     ConstantExpression returns InfixExpression
	 *
	 * Constraint:
	 *     (
	 *         (left=ConcatenationExpression_InfixExpression_1_0 op='::' right=ConcatenationExpression) | 
	 *         (left=LogicalOrExpression_InfixExpression_1_0 op='||' right=LogicalOrExpression) | 
	 *         (left=LogicalAndExpression_InfixExpression_1_0 op='&&' right=LogicalAndExpression) | 
	 *         (left=InclusiveOrExpression_InfixExpression_1_0 op='|' right=InclusiveOrExpression) | 
	 *         (left=ExclusiveOrExpression_InfixExpression_1_0 op='^' right=ExclusiveOrExpression) | 
	 *         (left=AndExpression_InfixExpression_1_0 op='&' right=AndExpression) | 
	 *         (left=EqualityExpression_InfixExpression_1_0 (op='==' | op='!=') right=EqualityExpression) | 
	 *         (left=RelationalExpression_InfixExpression_1_0 (op='<' | op='>' | op='<=' | op='>=') right=RelationalExpression) | 
	 *         (left=ShiftExpression_InfixExpression_1_0 (op='<<' | op='>>') right=ShiftExpression) | 
	 *         (left=AdditiveExpression_InfixExpression_1_0 (op='+' | op='-') right=AdditiveExpression) | 
	 *         (left=MultiplicativeExpression_InfixExpression_1_0 (op='*' | op='/' | op='%') right=MultiplicativeExpression)
	 *     )
	 */
	protected void sequence_AdditiveExpression_AndExpression_ConcatenationExpression_EqualityExpression_ExclusiveOrExpression_InclusiveOrExpression_LogicalAndExpression_LogicalOrExpression_MultiplicativeExpression_RelationalExpression_ShiftExpression(ISerializationContext context, InfixExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ConcatenationExpression.InfixExpression_1_0 returns InfixExpression
	 *     LogicalOrExpression returns InfixExpression
	 *
	 * Constraint:
	 *     (
	 *         (left=LogicalOrExpression_InfixExpression_1_0 op='||' right=LogicalOrExpression) | 
	 *         (left=LogicalAndExpression_InfixExpression_1_0 op='&&' right=LogicalAndExpression) | 
	 *         (left=InclusiveOrExpression_InfixExpression_1_0 op='|' right=InclusiveOrExpression) | 
	 *         (left=ExclusiveOrExpression_InfixExpression_1_0 op='^' right=ExclusiveOrExpression) | 
	 *         (left=AndExpression_InfixExpression_1_0 op='&' right=AndExpression) | 
	 *         (left=EqualityExpression_InfixExpression_1_0 (op='==' | op='!=') right=EqualityExpression) | 
	 *         (left=RelationalExpression_InfixExpression_1_0 (op='<' | op='>' | op='<=' | op='>=') right=RelationalExpression) | 
	 *         (left=ShiftExpression_InfixExpression_1_0 (op='<<' | op='>>') right=ShiftExpression) | 
	 *         (left=AdditiveExpression_InfixExpression_1_0 (op='+' | op='-') right=AdditiveExpression) | 
	 *         (left=MultiplicativeExpression_InfixExpression_1_0 (op='*' | op='/' | op='%') right=MultiplicativeExpression)
	 *     )
	 */
	protected void sequence_AdditiveExpression_AndExpression_EqualityExpression_ExclusiveOrExpression_InclusiveOrExpression_LogicalAndExpression_LogicalOrExpression_MultiplicativeExpression_RelationalExpression_ShiftExpression(ISerializationContext context, InfixExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LogicalOrExpression.InfixExpression_1_0 returns InfixExpression
	 *     LogicalAndExpression returns InfixExpression
	 *
	 * Constraint:
	 *     (
	 *         (left=LogicalAndExpression_InfixExpression_1_0 op='&&' right=LogicalAndExpression) | 
	 *         (left=InclusiveOrExpression_InfixExpression_1_0 op='|' right=InclusiveOrExpression) | 
	 *         (left=ExclusiveOrExpression_InfixExpression_1_0 op='^' right=ExclusiveOrExpression) | 
	 *         (left=AndExpression_InfixExpression_1_0 op='&' right=AndExpression) | 
	 *         (left=EqualityExpression_InfixExpression_1_0 (op='==' | op='!=') right=EqualityExpression) | 
	 *         (left=RelationalExpression_InfixExpression_1_0 (op='<' | op='>' | op='<=' | op='>=') right=RelationalExpression) | 
	 *         (left=ShiftExpression_InfixExpression_1_0 (op='<<' | op='>>') right=ShiftExpression) | 
	 *         (left=AdditiveExpression_InfixExpression_1_0 (op='+' | op='-') right=AdditiveExpression) | 
	 *         (left=MultiplicativeExpression_InfixExpression_1_0 (op='*' | op='/' | op='%') right=MultiplicativeExpression)
	 *     )
	 */
	protected void sequence_AdditiveExpression_AndExpression_EqualityExpression_ExclusiveOrExpression_InclusiveOrExpression_LogicalAndExpression_MultiplicativeExpression_RelationalExpression_ShiftExpression(ISerializationContext context, InfixExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LogicalAndExpression.InfixExpression_1_0 returns InfixExpression
	 *     InclusiveOrExpression returns InfixExpression
	 *
	 * Constraint:
	 *     (
	 *         (left=InclusiveOrExpression_InfixExpression_1_0 op='|' right=InclusiveOrExpression) | 
	 *         (left=ExclusiveOrExpression_InfixExpression_1_0 op='^' right=ExclusiveOrExpression) | 
	 *         (left=AndExpression_InfixExpression_1_0 op='&' right=AndExpression) | 
	 *         (left=EqualityExpression_InfixExpression_1_0 (op='==' | op='!=') right=EqualityExpression) | 
	 *         (left=RelationalExpression_InfixExpression_1_0 (op='<' | op='>' | op='<=' | op='>=') right=RelationalExpression) | 
	 *         (left=ShiftExpression_InfixExpression_1_0 (op='<<' | op='>>') right=ShiftExpression) | 
	 *         (left=AdditiveExpression_InfixExpression_1_0 (op='+' | op='-') right=AdditiveExpression) | 
	 *         (left=MultiplicativeExpression_InfixExpression_1_0 (op='*' | op='/' | op='%') right=MultiplicativeExpression)
	 *     )
	 */
	protected void sequence_AdditiveExpression_AndExpression_EqualityExpression_ExclusiveOrExpression_InclusiveOrExpression_MultiplicativeExpression_RelationalExpression_ShiftExpression(ISerializationContext context, InfixExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     InclusiveOrExpression.InfixExpression_1_0 returns InfixExpression
	 *     ExclusiveOrExpression returns InfixExpression
	 *
	 * Constraint:
	 *     (
	 *         (left=ExclusiveOrExpression_InfixExpression_1_0 op='^' right=ExclusiveOrExpression) | 
	 *         (left=AndExpression_InfixExpression_1_0 op='&' right=AndExpression) | 
	 *         (left=EqualityExpression_InfixExpression_1_0 (op='==' | op='!=') right=EqualityExpression) | 
	 *         (left=RelationalExpression_InfixExpression_1_0 (op='<' | op='>' | op='<=' | op='>=') right=RelationalExpression) | 
	 *         (left=ShiftExpression_InfixExpression_1_0 (op='<<' | op='>>') right=ShiftExpression) | 
	 *         (left=AdditiveExpression_InfixExpression_1_0 (op='+' | op='-') right=AdditiveExpression) | 
	 *         (left=MultiplicativeExpression_InfixExpression_1_0 (op='*' | op='/' | op='%') right=MultiplicativeExpression)
	 *     )
	 */
	protected void sequence_AdditiveExpression_AndExpression_EqualityExpression_ExclusiveOrExpression_MultiplicativeExpression_RelationalExpression_ShiftExpression(ISerializationContext context, InfixExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExclusiveOrExpression.InfixExpression_1_0 returns InfixExpression
	 *     AndExpression returns InfixExpression
	 *
	 * Constraint:
	 *     (
	 *         (left=AndExpression_InfixExpression_1_0 op='&' right=AndExpression) | 
	 *         (left=EqualityExpression_InfixExpression_1_0 (op='==' | op='!=') right=EqualityExpression) | 
	 *         (left=RelationalExpression_InfixExpression_1_0 (op='<' | op='>' | op='<=' | op='>=') right=RelationalExpression) | 
	 *         (left=ShiftExpression_InfixExpression_1_0 (op='<<' | op='>>') right=ShiftExpression) | 
	 *         (left=AdditiveExpression_InfixExpression_1_0 (op='+' | op='-') right=AdditiveExpression) | 
	 *         (left=MultiplicativeExpression_InfixExpression_1_0 (op='*' | op='/' | op='%') right=MultiplicativeExpression)
	 *     )
	 */
	protected void sequence_AdditiveExpression_AndExpression_EqualityExpression_MultiplicativeExpression_RelationalExpression_ShiftExpression(ISerializationContext context, InfixExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AndExpression.InfixExpression_1_0 returns InfixExpression
	 *     EqualityExpression returns InfixExpression
	 *
	 * Constraint:
	 *     (
	 *         (left=EqualityExpression_InfixExpression_1_0 (op='==' | op='!=') right=EqualityExpression) | 
	 *         (left=RelationalExpression_InfixExpression_1_0 (op='<' | op='>' | op='<=' | op='>=') right=RelationalExpression) | 
	 *         (left=ShiftExpression_InfixExpression_1_0 (op='<<' | op='>>') right=ShiftExpression) | 
	 *         (left=AdditiveExpression_InfixExpression_1_0 (op='+' | op='-') right=AdditiveExpression) | 
	 *         (left=MultiplicativeExpression_InfixExpression_1_0 (op='*' | op='/' | op='%') right=MultiplicativeExpression)
	 *     )
	 */
	protected void sequence_AdditiveExpression_EqualityExpression_MultiplicativeExpression_RelationalExpression_ShiftExpression(ISerializationContext context, InfixExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ShiftExpression.InfixExpression_1_0 returns InfixExpression
	 *     AdditiveExpression returns InfixExpression
	 *
	 * Constraint:
	 *     (
	 *         (left=AdditiveExpression_InfixExpression_1_0 (op='+' | op='-') right=AdditiveExpression) | 
	 *         (left=MultiplicativeExpression_InfixExpression_1_0 (op='*' | op='/' | op='%') right=MultiplicativeExpression)
	 *     )
	 */
	protected void sequence_AdditiveExpression_MultiplicativeExpression(ISerializationContext context, InfixExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EqualityExpression.InfixExpression_1_0 returns InfixExpression
	 *     RelationalExpression returns InfixExpression
	 *
	 * Constraint:
	 *     (
	 *         (left=RelationalExpression_InfixExpression_1_0 (op='<' | op='>' | op='<=' | op='>=') right=RelationalExpression) | 
	 *         (left=ShiftExpression_InfixExpression_1_0 (op='<<' | op='>>') right=ShiftExpression) | 
	 *         (left=AdditiveExpression_InfixExpression_1_0 (op='+' | op='-') right=AdditiveExpression) | 
	 *         (left=MultiplicativeExpression_InfixExpression_1_0 (op='*' | op='/' | op='%') right=MultiplicativeExpression)
	 *     )
	 */
	protected void sequence_AdditiveExpression_MultiplicativeExpression_RelationalExpression_ShiftExpression(ISerializationContext context, InfixExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RelationalExpression.InfixExpression_1_0 returns InfixExpression
	 *     ShiftExpression returns InfixExpression
	 *
	 * Constraint:
	 *     (
	 *         (left=ShiftExpression_InfixExpression_1_0 (op='<<' | op='>>') right=ShiftExpression) | 
	 *         (left=AdditiveExpression_InfixExpression_1_0 (op='+' | op='-') right=AdditiveExpression) | 
	 *         (left=MultiplicativeExpression_InfixExpression_1_0 (op='*' | op='/' | op='%') right=MultiplicativeExpression)
	 *     )
	 */
	protected void sequence_AdditiveExpression_MultiplicativeExpression_ShiftExpression(ISerializationContext context, InfixExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AssignmentExpression2 returns AssignmentExpression
	 *     AssignmentExpression2.AssignmentExpression_1_0 returns AssignmentExpression
	 *
	 * Constraint:
	 *     (
	 *         left=AssignmentExpression2_AssignmentExpression_1_0 
	 *         (
	 *             assignment+='=' | 
	 *             assignment+='*=' | 
	 *             assignment+='/=' | 
	 *             assignment+='%=' | 
	 *             assignment+='+=' | 
	 *             assignment+='-=' | 
	 *             assignment+='<<=' | 
	 *             assignment+='>>=' | 
	 *             assignment+='&=' | 
	 *             assignment+='^=' | 
	 *             assignment+='|='
	 *         ) 
	 *         rights+=ConditionalExpression
	 *     )
	 */
	protected void sequence_AssignmentExpression2(ISerializationContext context, AssignmentExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns AssignmentExpression
	 *     Expression.Expression_1_0 returns AssignmentExpression
	 *     AssignmentExpression returns AssignmentExpression
	 *     AssignmentExpression.AssignmentExpression_1_0 returns AssignmentExpression
	 *
	 * Constraint:
	 *     (
	 *         left=AssignmentExpression_AssignmentExpression_1_0 
	 *         (
	 *             assignment+='=' | 
	 *             assignment+='*=' | 
	 *             assignment+='/=' | 
	 *             assignment+='%=' | 
	 *             assignment+='+=' | 
	 *             assignment+='-=' | 
	 *             assignment+='<<=' | 
	 *             assignment+='>>=' | 
	 *             assignment+='&=' | 
	 *             assignment+='^=' | 
	 *             assignment+='|='
	 *         ) 
	 *         rights+=ConditionalExpression
	 *     )
	 */
	protected void sequence_AssignmentExpression(ISerializationContext context, AssignmentExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Attribute returns Attribute
	 *
	 * Constraint:
	 *     (type=DeclarationAttribute val=ConditionalExpression?)
	 */
	protected void sequence_Attribute(ISerializationContext context, Attribute semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Field returns BitField
	 *     BitField returns BitField
	 *     VariableRef returns BitField
	 *
	 * Constraint:
	 *     (name=ID bitRange=RangeSpec type=BitfieldDataType?)
	 */
	protected void sequence_BitField(ISerializationContext context, BitField semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BitSizeSpecifier returns BitSizeSpecifier
	 *
	 * Constraint:
	 *     (size+=PrimaryExpression (size+=PrimaryExpression size+=PrimaryExpression size+=PrimaryExpression)?)
	 */
	protected void sequence_BitSizeSpecifier(ISerializationContext context, BitSizeSpecifier semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BitSizeValue returns BitSizeValue
	 *
	 * Constraint:
	 *     (val+=IntegerConstant | constant+=[Constant|ID])
	 */
	protected void sequence_BitSizeValue(ISerializationContext context, BitSizeValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Field returns BitValue
	 *     BitValue returns BitValue
	 *     VariableRef returns BitValue
	 *
	 * Constraint:
	 *     name=BVAL
	 */
	protected void sequence_BitValue(ISerializationContext context, BitValue semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CoreDslPackage.Literals.VARIABLE_REF__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CoreDslPackage.Literals.VARIABLE_REF__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBitValueAccess().getNameBVALTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Constant returns BoolConstant
	 *     BoolConstant returns BoolConstant
	 *
	 * Constraint:
	 *     val=BOOLEAN
	 */
	protected void sequence_BoolConstant(ISerializationContext context, BoolConstant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CoreDslPackage.Literals.BOOL_CONSTANT__VAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CoreDslPackage.Literals.BOOL_CONSTANT__VAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBoolConstantAccess().getValBOOLEANTerminalRuleCall_0(), semanticObject.isVal());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ConditionalExpression returns CastExpression
	 *     ConditionalExpression.ConditionalExpression_1_0 returns CastExpression
	 *     ConcatenationExpression returns CastExpression
	 *     ConcatenationExpression.InfixExpression_1_0 returns CastExpression
	 *     LogicalOrExpression returns CastExpression
	 *     LogicalOrExpression.InfixExpression_1_0 returns CastExpression
	 *     LogicalAndExpression returns CastExpression
	 *     LogicalAndExpression.InfixExpression_1_0 returns CastExpression
	 *     InclusiveOrExpression returns CastExpression
	 *     InclusiveOrExpression.InfixExpression_1_0 returns CastExpression
	 *     ExclusiveOrExpression returns CastExpression
	 *     ExclusiveOrExpression.InfixExpression_1_0 returns CastExpression
	 *     AndExpression returns CastExpression
	 *     AndExpression.InfixExpression_1_0 returns CastExpression
	 *     EqualityExpression returns CastExpression
	 *     EqualityExpression.InfixExpression_1_0 returns CastExpression
	 *     RelationalExpression returns CastExpression
	 *     RelationalExpression.InfixExpression_1_0 returns CastExpression
	 *     ShiftExpression returns CastExpression
	 *     ShiftExpression.InfixExpression_1_0 returns CastExpression
	 *     AdditiveExpression returns CastExpression
	 *     AdditiveExpression.InfixExpression_1_0 returns CastExpression
	 *     MultiplicativeExpression returns CastExpression
	 *     MultiplicativeExpression.InfixExpression_1_0 returns CastExpression
	 *     CastExpression returns CastExpression
	 *     ConstantExpression returns CastExpression
	 *
	 * Constraint:
	 *     (type=DataTypeSpecifier size=BitSizeSpecifier? left=CastExpression)
	 */
	protected void sequence_CastExpression(ISerializationContext context, CastExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Constant returns CharacterConstant
	 *     CharacterConstant returns CharacterConstant
	 *
	 * Constraint:
	 *     (val=CHARCONST | (enc='L' val=CHARCONST) | (enc='u' val=CHARCONST) | (enc='U' val=CHARCONST))
	 */
	protected void sequence_CharacterConstant(ISerializationContext context, CharacterConstant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns CompoundStatement
	 *     CompoundStatement returns CompoundStatement
	 *     BlockItem returns CompoundStatement
	 *
	 * Constraint:
	 *     items+=BlockItem*
	 */
	protected void sequence_CompoundStatement(ISerializationContext context, CompoundStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ConditionalExpression returns ConditionalExpression
	 *     ConstantExpression returns ConditionalExpression
	 *
	 * Constraint:
	 *     (cond=ConditionalExpression_ConditionalExpression_1_0 left=ConditionalExpression right=ConditionalExpression)
	 */
	protected void sequence_ConditionalExpression(ISerializationContext context, ConditionalExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CoreDslPackage.Literals.CONDITIONAL_EXPRESSION__COND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CoreDslPackage.Literals.CONDITIONAL_EXPRESSION__COND));
			if (transientValues.isValueTransient(semanticObject, CoreDslPackage.Literals.EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CoreDslPackage.Literals.EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, CoreDslPackage.Literals.EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CoreDslPackage.Literals.EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConditionalExpressionAccess().getConditionalExpressionCondAction_1_0(), semanticObject.getCond());
		feeder.accept(grammarAccess.getConditionalExpressionAccess().getLeftConditionalExpressionParserRuleCall_1_2_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getConditionalExpressionAccess().getRightConditionalExpressionParserRuleCall_1_4_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ISA returns CoreDef
	 *     CoreDef returns CoreDef
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         (contributingType+=[InstructionSet|ID] contributingType+=[InstructionSet|ID]*)? 
	 *         constants+=Declaration* 
	 *         spaces+=Declaration* 
	 *         regs+=Declaration* 
	 *         instr+=Instruction*
	 *     )
	 */
	protected void sequence_CoreDef(ISerializationContext context, CoreDef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BlockItem returns TypeOrVarDeclaration
	 *     Declaration returns TypeOrVarDeclaration
	 *     TypeOrVarDeclaration returns TypeOrVarDeclaration
	 *
	 * Constraint:
	 *     (
	 *         (storage+=StorageClassSpecifier | qualifiers+=TypeQualifier | attrs+=Attribute)* 
	 *         type=TypeSpecifier 
	 *         size=BitSizeSpecifier? 
	 *         (ptr='*' | ptr='&')? 
	 *         (init+=InitDeclarator init+=InitDeclarator*)?
	 *     )
	 */
	protected void sequence_DeclarationSpecifier_TypeOrVarDeclaration(ISerializationContext context, TypeOrVarDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DescriptionContent returns DescriptionContent
	 *
	 * Constraint:
	 *     (imports+=Import* definitions+=ISA+)
	 */
	protected void sequence_DescriptionContent(ISerializationContext context, DescriptionContent semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DesignatedInitializer returns DesignatedInitializer
	 *
	 * Constraint:
	 *     (designators+=Designator+ init=Initializer)
	 */
	protected void sequence_DesignatedInitializer(ISerializationContext context, DesignatedInitializer semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Designator returns Designator
	 *
	 * Constraint:
	 *     (idx=ConstantExpression | prop=ID)
	 */
	protected void sequence_Designator(ISerializationContext context, Designator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AbstractDeclarator returns DirectAbstractDeclarator
	 *     DirectAbstractDeclarator returns DirectAbstractDeclarator
	 *
	 * Constraint:
	 *     ((params+=ParameterDeclaration parameters+=ParameterDeclaration*) | declarator=AbstractDeclarator | expr=ConstantExpression)?
	 */
	protected void sequence_DirectAbstractDeclarator_ParameterList(ISerializationContext context, DirectAbstractDeclarator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DirectDeclarator.DirectDeclarator_2_0_0 returns DirectDeclarator
	 *     DirectDeclarator.DirectDeclarator_2_1_0 returns DirectDeclarator
	 *
	 * Constraint:
	 *     (name=ID index=IntegerConstant?)
	 */
	protected void sequence_DirectDeclarator_DirectDeclarator_2_0_0_DirectDeclarator_2_1_0(ISerializationContext context, DirectDeclarator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DirectDeclarator returns DirectDeclarator
	 *     VariableRef returns DirectDeclarator
	 *
	 * Constraint:
	 *     (
	 *         (name=ID index=IntegerConstant?) | 
	 *         (left=DirectDeclarator_DirectDeclarator_2_0_0 size+=ConditionalExpression+) | 
	 *         (left=DirectDeclarator_DirectDeclarator_2_1_0 params+=ParameterDeclaration parameters+=ParameterDeclaration*)
	 *     )
	 */
	protected void sequence_DirectDeclarator_ParameterList(ISerializationContext context, DirectDeclarator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EmptyExpression returns Expression
	 *
	 * Constraint:
	 *     {Expression}
	 */
	protected void sequence_EmptyExpression(ISerializationContext context, Expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     StringLiteral returns StringLiteral
	 *
	 * Constraint:
	 *     ((prefix='u8' | prefix='u' | prefix='U' | prefix='L')? val=STRING)
	 */
	protected void sequence_EncodingPrefix_StringLiteral(ISerializationContext context, StringLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Encoding returns Encoding
	 *
	 * Constraint:
	 *     (fields+=Field fields+=Field*)
	 */
	protected void sequence_Encoding(ISerializationContext context, Encoding semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TypeSpecifier returns EnumSpecifier
	 *     DataTypeSpecifier returns EnumSpecifier
	 *     EnumSpecifier returns EnumSpecifier
	 *
	 * Constraint:
	 *     ((name=ID? enumerators+=Enumerator enumerators+=Enumerator*) | name=ID)
	 */
	protected void sequence_EnumSpecifier_EnumeratorList(ISerializationContext context, EnumSpecifier semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Enumerator returns Enumerator
	 *
	 * Constraint:
	 *     (name=ID | (name=ID expression=ConstantExpression))
	 */
	protected void sequence_Enumerator(ISerializationContext context, Enumerator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns ExpressionStatement
	 *     BlockItem returns ExpressionStatement
	 *     ExpressionStatement returns ExpressionStatement
	 *
	 * Constraint:
	 *     expr=AssignmentExpression?
	 */
	protected void sequence_ExpressionStatement(ISerializationContext context, ExpressionStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Expression
	 *
	 * Constraint:
	 *     (left=Expression_Expression_1_0 right=AssignmentExpression)
	 */
	protected void sequence_Expression(ISerializationContext context, Expression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CoreDslPackage.Literals.EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CoreDslPackage.Literals.EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, CoreDslPackage.Literals.EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CoreDslPackage.Literals.EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpressionAccess().getExpressionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getExpressionAccess().getRightAssignmentExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Constant returns FloatingConstant
	 *     FloatingConstant returns FloatingConstant
	 *
	 * Constraint:
	 *     val=FLOAT
	 */
	protected void sequence_FloatingConstant(ISerializationContext context, FloatingConstant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CoreDslPackage.Literals.FLOATING_CONSTANT__VAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CoreDslPackage.Literals.FLOATING_CONSTANT__VAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFloatingConstantAccess().getValFLOATTerminalRuleCall_0(), semanticObject.getVal());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns IterationStatement
	 *     BlockItem returns IterationStatement
	 *     IterationStatement returns IterationStatement
	 *
	 * Constraint:
	 *     (
	 *         (type='while' cond=ConditionalExpression stmt=Statement) | 
	 *         (type='do' stmt=Statement cond=ConditionalExpression) | 
	 *         (
	 *             type='for' 
	 *             (startDecl=Declaration | startExpr=AssignmentExpression2)? 
	 *             endExpr=ConditionalExpression? 
	 *             (loopExprs+=AssignmentExpression loopExprs+=AssignmentExpression*)? 
	 *             stmt=Statement
	 *         )
	 *     )
	 */
	protected void sequence_ForCondition_IterationStatement(ISerializationContext context, IterationStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FunctionDefinition returns FunctionDefinition
	 *     VariableRef returns FunctionDefinition
	 *
	 * Constraint:
	 *     (
	 *         (extern?='extern' type=TypeSpecifier name=ID (params+=ParameterDeclaration parameters+=ParameterDeclaration* statement=CompoundStatement?)?) | 
	 *         (type=TypeSpecifier name=ID (params+=ParameterDeclaration parameters+=ParameterDeclaration* statement=CompoundStatement?)?) | 
	 *         (type=TypeSpecifier name=ID statement=CompoundStatement?)
	 *     )
	 */
	protected void sequence_FunctionDefinition_ParameterList(ISerializationContext context, FunctionDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns IfStatement
	 *     BlockItem returns IfStatement
	 *     SelectionStatement returns IfStatement
	 *     IfStatement returns IfStatement
	 *
	 * Constraint:
	 *     (cond=ConditionalExpression thenStmt=Statement elseStmt=Statement?)
	 */
	protected void sequence_IfStatement(ISerializationContext context, IfStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Import returns Import
	 *
	 * Constraint:
	 *     importURI=STRING
	 */
	protected void sequence_Import(ISerializationContext context, Import semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CoreDslPackage.Literals.IMPORT__IMPORT_URI) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CoreDslPackage.Literals.IMPORT__IMPORT_URI));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getImportAccess().getImportURISTRINGTerminalRuleCall_1_0(), semanticObject.getImportURI());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     InitDeclarator returns InitDeclarator
	 *
	 * Constraint:
	 *     (declarator=DirectDeclarator attrs+=Attribute* initializer=Initializer?)
	 */
	protected void sequence_InitDeclarator(ISerializationContext context, InitDeclarator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Initializer returns Initializer
	 *
	 * Constraint:
	 *     (
	 *         expr=ConditionalExpression | 
	 *         ((init+=DesignatedInitializer | init+=Initializer) init+=DesignatedInitializer? (init+=Initializer? init+=DesignatedInitializer?)*)
	 *     )
	 */
	protected void sequence_Initializer_InitializerList(ISerializationContext context, Initializer semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ISA returns InstructionSet
	 *     InstructionSet returns InstructionSet
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         superType=[InstructionSet|ID]? 
	 *         constants+=Declaration* 
	 *         spaces+=Declaration* 
	 *         regs+=Declaration* 
	 *         func+=FunctionDefinition* 
	 *         instr+=Instruction*
	 *     )
	 */
	protected void sequence_InstructionSet(ISerializationContext context, InstructionSet semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Instruction returns Instruction
	 *
	 * Constraint:
	 *     (name=ID attributes+=InstrAttribute* encoding=Encoding disass=STRING? behavior=Statement)
	 */
	protected void sequence_Instruction(ISerializationContext context, Instruction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Constant returns IntegerConstant
	 *     IntegerConstant returns IntegerConstant
	 *
	 * Constraint:
	 *     val=INTEGER
	 */
	protected void sequence_IntegerConstant(ISerializationContext context, IntegerConstant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CoreDslPackage.Literals.INTEGER_CONSTANT__VAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CoreDslPackage.Literals.INTEGER_CONSTANT__VAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIntegerConstantAccess().getValINTEGERTerminalRuleCall_0(), semanticObject.getVal());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns JumpStatement
	 *     BlockItem returns JumpStatement
	 *     JumpStatement returns JumpStatement
	 *
	 * Constraint:
	 *     (type='continue' | type='break' | (type='return' expr=ConditionalExpression?))
	 */
	protected void sequence_JumpStatement(ISerializationContext context, JumpStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LabeledStatement returns LabeledStatement
	 *
	 * Constraint:
	 *     ((constExpr=ConstantExpression stmt=Statement) | stmt=Statement)
	 */
	protected void sequence_LabeledStatement(ISerializationContext context, LabeledStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AdditiveExpression.InfixExpression_1_0 returns InfixExpression
	 *     MultiplicativeExpression returns InfixExpression
	 *
	 * Constraint:
	 *     (left=MultiplicativeExpression_InfixExpression_1_0 (op='*' | op='/' | op='%') right=MultiplicativeExpression)
	 */
	protected void sequence_MultiplicativeExpression(ISerializationContext context, InfixExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ParameterDeclaration returns ParameterDeclaration
	 *
	 * Constraint:
	 *     (type=TypeSpecifier (declarator=DirectDeclarator | declarator=AbstractDeclarator)?)
	 */
	protected void sequence_ParameterDeclaration(ISerializationContext context, ParameterDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TypeSpecifier returns PodSpecifier
	 *     DataTypeSpecifier returns PodSpecifier
	 *     PodSpecifier returns PodSpecifier
	 *
	 * Constraint:
	 *     dataType+=DataTypes+
	 */
	protected void sequence_PodSpecifier(ISerializationContext context, PodSpecifier semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns PostfixExpression
	 *     Expression.Expression_1_0 returns PostfixExpression
	 *     AssignmentExpression returns PostfixExpression
	 *     AssignmentExpression.AssignmentExpression_1_0 returns PostfixExpression
	 *     AssignmentExpression2.AssignmentExpression_1_0 returns PostfixExpression
	 *     ConditionalExpression returns PostfixExpression
	 *     ConditionalExpression.ConditionalExpression_1_0 returns PostfixExpression
	 *     ConcatenationExpression returns PostfixExpression
	 *     ConcatenationExpression.InfixExpression_1_0 returns PostfixExpression
	 *     LogicalOrExpression returns PostfixExpression
	 *     LogicalOrExpression.InfixExpression_1_0 returns PostfixExpression
	 *     LogicalAndExpression returns PostfixExpression
	 *     LogicalAndExpression.InfixExpression_1_0 returns PostfixExpression
	 *     InclusiveOrExpression returns PostfixExpression
	 *     InclusiveOrExpression.InfixExpression_1_0 returns PostfixExpression
	 *     ExclusiveOrExpression returns PostfixExpression
	 *     ExclusiveOrExpression.InfixExpression_1_0 returns PostfixExpression
	 *     AndExpression returns PostfixExpression
	 *     AndExpression.InfixExpression_1_0 returns PostfixExpression
	 *     EqualityExpression returns PostfixExpression
	 *     EqualityExpression.InfixExpression_1_0 returns PostfixExpression
	 *     RelationalExpression returns PostfixExpression
	 *     RelationalExpression.InfixExpression_1_0 returns PostfixExpression
	 *     ShiftExpression returns PostfixExpression
	 *     ShiftExpression.InfixExpression_1_0 returns PostfixExpression
	 *     AdditiveExpression returns PostfixExpression
	 *     AdditiveExpression.InfixExpression_1_0 returns PostfixExpression
	 *     MultiplicativeExpression returns PostfixExpression
	 *     MultiplicativeExpression.InfixExpression_1_0 returns PostfixExpression
	 *     CastExpression returns PostfixExpression
	 *     PrefixExpression returns PostfixExpression
	 *     PostfixExpression returns PostfixExpression
	 *     PostfixExpression.PostfixExpression_1_0 returns PostfixExpression
	 *     ConstantExpression returns PostfixExpression
	 *
	 * Constraint:
	 *     (left=PostfixExpression_PostfixExpression_1_0 ops+=PostfixOperator)
	 */
	protected void sequence_PostfixExpression(ISerializationContext context, PostfixExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PostfixOperator returns PostfixOperator
	 *
	 * Constraint:
	 *     (
	 *         (op=LEFT_BR args+=ConditionalExpression args+=ConditionalExpression?) | 
	 *         (op='(' (args+=ConditionalExpression args+=ConditionalExpression*)?) | 
	 *         (op='.' member=[DirectDeclarator|ID]) | 
	 *         (op='->' member=[DirectDeclarator|ID]) | 
	 *         op='++' | 
	 *         op='--'
	 *     )
	 */
	protected void sequence_PostfixOperator(ISerializationContext context, PostfixOperator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns PrefixExpression
	 *     Expression.Expression_1_0 returns PrefixExpression
	 *     AssignmentExpression returns PrefixExpression
	 *     AssignmentExpression.AssignmentExpression_1_0 returns PrefixExpression
	 *     AssignmentExpression2.AssignmentExpression_1_0 returns PrefixExpression
	 *     ConditionalExpression returns PrefixExpression
	 *     ConditionalExpression.ConditionalExpression_1_0 returns PrefixExpression
	 *     ConcatenationExpression returns PrefixExpression
	 *     ConcatenationExpression.InfixExpression_1_0 returns PrefixExpression
	 *     LogicalOrExpression returns PrefixExpression
	 *     LogicalOrExpression.InfixExpression_1_0 returns PrefixExpression
	 *     LogicalAndExpression returns PrefixExpression
	 *     LogicalAndExpression.InfixExpression_1_0 returns PrefixExpression
	 *     InclusiveOrExpression returns PrefixExpression
	 *     InclusiveOrExpression.InfixExpression_1_0 returns PrefixExpression
	 *     ExclusiveOrExpression returns PrefixExpression
	 *     ExclusiveOrExpression.InfixExpression_1_0 returns PrefixExpression
	 *     AndExpression returns PrefixExpression
	 *     AndExpression.InfixExpression_1_0 returns PrefixExpression
	 *     EqualityExpression returns PrefixExpression
	 *     EqualityExpression.InfixExpression_1_0 returns PrefixExpression
	 *     RelationalExpression returns PrefixExpression
	 *     RelationalExpression.InfixExpression_1_0 returns PrefixExpression
	 *     ShiftExpression returns PrefixExpression
	 *     ShiftExpression.InfixExpression_1_0 returns PrefixExpression
	 *     AdditiveExpression returns PrefixExpression
	 *     AdditiveExpression.InfixExpression_1_0 returns PrefixExpression
	 *     MultiplicativeExpression returns PrefixExpression
	 *     MultiplicativeExpression.InfixExpression_1_0 returns PrefixExpression
	 *     CastExpression returns PrefixExpression
	 *     PrefixExpression returns PrefixExpression
	 *     ConstantExpression returns PrefixExpression
	 *
	 * Constraint:
	 *     (
	 *         (op='++' left=PrefixExpression) | 
	 *         (op='--' left=PrefixExpression) | 
	 *         (op='sizeof' (left=PostfixExpression | type=DataTypeSpecifier)) | 
	 *         (
	 *             (
	 *                 op='&' | 
	 *                 op='*' | 
	 *                 op='+' | 
	 *                 op='-' | 
	 *                 op='~' | 
	 *                 op='!'
	 *             ) 
	 *             left=CastExpression
	 *         )
	 *     )
	 */
	protected void sequence_PrefixExpression_UnaryOperator(ISerializationContext context, PrefixExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns PrimaryExpression
	 *     Expression.Expression_1_0 returns PrimaryExpression
	 *     AssignmentExpression returns PrimaryExpression
	 *     AssignmentExpression.AssignmentExpression_1_0 returns PrimaryExpression
	 *     AssignmentExpression2.AssignmentExpression_1_0 returns PrimaryExpression
	 *     ConditionalExpression returns PrimaryExpression
	 *     ConditionalExpression.ConditionalExpression_1_0 returns PrimaryExpression
	 *     ConcatenationExpression returns PrimaryExpression
	 *     ConcatenationExpression.InfixExpression_1_0 returns PrimaryExpression
	 *     LogicalOrExpression returns PrimaryExpression
	 *     LogicalOrExpression.InfixExpression_1_0 returns PrimaryExpression
	 *     LogicalAndExpression returns PrimaryExpression
	 *     LogicalAndExpression.InfixExpression_1_0 returns PrimaryExpression
	 *     InclusiveOrExpression returns PrimaryExpression
	 *     InclusiveOrExpression.InfixExpression_1_0 returns PrimaryExpression
	 *     ExclusiveOrExpression returns PrimaryExpression
	 *     ExclusiveOrExpression.InfixExpression_1_0 returns PrimaryExpression
	 *     AndExpression returns PrimaryExpression
	 *     AndExpression.InfixExpression_1_0 returns PrimaryExpression
	 *     EqualityExpression returns PrimaryExpression
	 *     EqualityExpression.InfixExpression_1_0 returns PrimaryExpression
	 *     RelationalExpression returns PrimaryExpression
	 *     RelationalExpression.InfixExpression_1_0 returns PrimaryExpression
	 *     ShiftExpression returns PrimaryExpression
	 *     ShiftExpression.InfixExpression_1_0 returns PrimaryExpression
	 *     AdditiveExpression returns PrimaryExpression
	 *     AdditiveExpression.InfixExpression_1_0 returns PrimaryExpression
	 *     MultiplicativeExpression returns PrimaryExpression
	 *     MultiplicativeExpression.InfixExpression_1_0 returns PrimaryExpression
	 *     CastExpression returns PrimaryExpression
	 *     PrefixExpression returns PrimaryExpression
	 *     PostfixExpression returns PrimaryExpression
	 *     PostfixExpression.PostfixExpression_1_0 returns PrimaryExpression
	 *     PrimaryExpression returns PrimaryExpression
	 *     ConstantExpression returns PrimaryExpression
	 *
	 * Constraint:
	 *     (ref=[VariableRef|ID] | constant=Constant | literal+=StringLiteral+ | left=ConditionalExpression)
	 */
	protected void sequence_PrimaryExpression(ISerializationContext context, PrimaryExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RangeSpec returns RangeSpec
	 *
	 * Constraint:
	 *     (left=IntegerConstant right=IntegerConstant)
	 */
	protected void sequence_RangeSpec(ISerializationContext context, RangeSpec semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CoreDslPackage.Literals.RANGE_SPEC__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CoreDslPackage.Literals.RANGE_SPEC__LEFT));
			if (transientValues.isValueTransient(semanticObject, CoreDslPackage.Literals.RANGE_SPEC__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CoreDslPackage.Literals.RANGE_SPEC__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRangeSpecAccess().getLeftIntegerConstantParserRuleCall_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getRangeSpecAccess().getRightIntegerConstantParserRuleCall_3_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns SpawnStatement
	 *     BlockItem returns SpawnStatement
	 *     SpawnStatement returns SpawnStatement
	 *
	 * Constraint:
	 *     stmt=Statement
	 */
	protected void sequence_SpawnStatement(ISerializationContext context, SpawnStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CoreDslPackage.Literals.SPAWN_STATEMENT__STMT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CoreDslPackage.Literals.SPAWN_STATEMENT__STMT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSpawnStatementAccess().getStmtStatementParserRuleCall_1_0(), semanticObject.getStmt());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     StructDeclarationSpecifier returns StructDeclarationSpecifier
	 *
	 * Constraint:
	 *     (type=TypeSpecifier | qualifiers+=TypeQualifier)
	 */
	protected void sequence_StructDeclarationSpecifier(ISerializationContext context, StructDeclarationSpecifier semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     StructDeclaration returns StructDeclaration
	 *
	 * Constraint:
	 *     (specifier=StructDeclarationSpecifier decls+=DirectDeclarator decls+=DirectDeclarator*)
	 */
	protected void sequence_StructDeclaration(ISerializationContext context, StructDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TypeSpecifier returns StructOrUnionSpecifier
	 *     DataTypeSpecifier returns StructOrUnionSpecifier
	 *     StructOrUnionSpecifier returns StructOrUnionSpecifier
	 *
	 * Constraint:
	 *     ((composeType=StructOrUnion name=ID? decls+=StructDeclaration*) | (composeType=StructOrUnion name=ID))
	 */
	protected void sequence_StructOrUnionSpecifier(ISerializationContext context, StructOrUnionSpecifier semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns SwitchStatement
	 *     BlockItem returns SwitchStatement
	 *     SelectionStatement returns SwitchStatement
	 *     SwitchStatement returns SwitchStatement
	 *
	 * Constraint:
	 *     (cond=ConditionalExpression items+=LabeledStatement)
	 */
	protected void sequence_SwitchStatement(ISerializationContext context, SwitchStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
