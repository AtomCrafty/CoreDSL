/*
 * generated by Xtext 2.22.0
 */
package com.minres.coredsl.serializer;

import com.google.inject.Inject;
import com.minres.coredsl.coreDsl.ArithmeticExpression;
import com.minres.coredsl.coreDsl.AssignmentExpression;
import com.minres.coredsl.coreDsl.BitField;
import com.minres.coredsl.coreDsl.BitSizeSpecifier;
import com.minres.coredsl.coreDsl.BitSizeValue;
import com.minres.coredsl.coreDsl.BitValue;
import com.minres.coredsl.coreDsl.BoolConstant;
import com.minres.coredsl.coreDsl.CastExpression;
import com.minres.coredsl.coreDsl.CharacterConstant;
import com.minres.coredsl.coreDsl.CompoundStatement;
import com.minres.coredsl.coreDsl.ConditionalExpression;
import com.minres.coredsl.coreDsl.CoreDef;
import com.minres.coredsl.coreDsl.CoreDslPackage;
import com.minres.coredsl.coreDsl.DescriptionContent;
import com.minres.coredsl.coreDsl.DesignatedInitializer;
import com.minres.coredsl.coreDsl.Designator;
import com.minres.coredsl.coreDsl.DirectAbstractDeclarator;
import com.minres.coredsl.coreDsl.DirectDeclarator;
import com.minres.coredsl.coreDsl.Encoding;
import com.minres.coredsl.coreDsl.EnumSpecifier;
import com.minres.coredsl.coreDsl.Enumerator;
import com.minres.coredsl.coreDsl.Expression;
import com.minres.coredsl.coreDsl.ExpressionStatement;
import com.minres.coredsl.coreDsl.FloatingConstant;
import com.minres.coredsl.coreDsl.FunctionDefinition;
import com.minres.coredsl.coreDsl.IfStatement;
import com.minres.coredsl.coreDsl.Import;
import com.minres.coredsl.coreDsl.InitDeclarator;
import com.minres.coredsl.coreDsl.Initializer;
import com.minres.coredsl.coreDsl.Instruction;
import com.minres.coredsl.coreDsl.InstructionSet;
import com.minres.coredsl.coreDsl.IntegerConstant;
import com.minres.coredsl.coreDsl.IterationStatement;
import com.minres.coredsl.coreDsl.JumpStatement;
import com.minres.coredsl.coreDsl.LabeledStatement;
import com.minres.coredsl.coreDsl.LogicalExpr;
import com.minres.coredsl.coreDsl.ParameterDeclaration;
import com.minres.coredsl.coreDsl.PodSpecifier;
import com.minres.coredsl.coreDsl.PostfixExpression;
import com.minres.coredsl.coreDsl.PostfixOperator;
import com.minres.coredsl.coreDsl.PrimaryExpression;
import com.minres.coredsl.coreDsl.RangeSpec;
import com.minres.coredsl.coreDsl.StringLiteral;
import com.minres.coredsl.coreDsl.StructDeclaration;
import com.minres.coredsl.coreDsl.StructDeclarationSpecifier;
import com.minres.coredsl.coreDsl.StructOrUnionSpecifier;
import com.minres.coredsl.coreDsl.SwitchStatement;
import com.minres.coredsl.coreDsl.TypeOrVarDeclaration;
import com.minres.coredsl.coreDsl.TypedefDeclaration;
import com.minres.coredsl.coreDsl.TypedefRef;
import com.minres.coredsl.coreDsl.UnaryExpression;
import com.minres.coredsl.services.CoreDslGrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class CoreDslSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private CoreDslGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == CoreDslPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case CoreDslPackage.ARITHMETIC_EXPRESSION:
				if (action == grammarAccess.getShiftExpressionAccess().getArithmeticExpressionLeftAction_1_0()
						|| rule == grammarAccess.getAdditiveExpressionRule()) {
					sequence_AdditiveExpression_MultiplicativeExpression(context, (ArithmeticExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getConditionalExpressionRule()
						|| action == grammarAccess.getConditionalExpressionAccess().getConditionalExpressionCondAction_1_0()
						|| rule == grammarAccess.getLogicalOrExpressionRule()
						|| action == grammarAccess.getLogicalOrExpressionAccess().getLogicalExprLeftAction_1_0()
						|| rule == grammarAccess.getLogicalAndExpressionRule()
						|| action == grammarAccess.getLogicalAndExpressionAccess().getLogicalExprLeftAction_1_0()
						|| rule == grammarAccess.getInclusiveOrExpressionRule()
						|| action == grammarAccess.getInclusiveOrExpressionAccess().getLogicalExprLeftAction_1_0()
						|| rule == grammarAccess.getExclusiveOrExpressionRule()
						|| action == grammarAccess.getExclusiveOrExpressionAccess().getLogicalExprLeftAction_1_0()
						|| rule == grammarAccess.getAndExpressionRule()
						|| action == grammarAccess.getAndExpressionAccess().getLogicalExprLeftAction_1_0()
						|| rule == grammarAccess.getEqualityExpressionRule()
						|| action == grammarAccess.getEqualityExpressionAccess().getLogicalExprLeftAction_1_0()
						|| rule == grammarAccess.getRelationalExpressionRule()
						|| action == grammarAccess.getRelationalExpressionAccess().getLogicalExprLeftAction_1_0()
						|| rule == grammarAccess.getShiftExpressionRule()
						|| rule == grammarAccess.getConstantExpressionRule()) {
					sequence_AdditiveExpression_MultiplicativeExpression_ShiftExpression(context, (ArithmeticExpression) semanticObject); 
					return; 
				}
				else if (action == grammarAccess.getAdditiveExpressionAccess().getArithmeticExpressionLeftAction_1_0()
						|| rule == grammarAccess.getMultiplicativeExpressionRule()) {
					sequence_MultiplicativeExpression(context, (ArithmeticExpression) semanticObject); 
					return; 
				}
				else break;
			case CoreDslPackage.ASSIGNMENT_EXPRESSION:
				sequence_AssignmentExpression(context, (AssignmentExpression) semanticObject); 
				return; 
			case CoreDslPackage.BIT_FIELD:
				sequence_BitField(context, (BitField) semanticObject); 
				return; 
			case CoreDslPackage.BIT_SIZE_SPECIFIER:
				sequence_BitSizeSpecifier(context, (BitSizeSpecifier) semanticObject); 
				return; 
			case CoreDslPackage.BIT_SIZE_VALUE:
				sequence_BitSizeValue(context, (BitSizeValue) semanticObject); 
				return; 
			case CoreDslPackage.BIT_VALUE:
				sequence_BitValue(context, (BitValue) semanticObject); 
				return; 
			case CoreDslPackage.BOOL_CONSTANT:
				sequence_BoolConstant(context, (BoolConstant) semanticObject); 
				return; 
			case CoreDslPackage.CAST_EXPRESSION:
				sequence_CastExpression(context, (CastExpression) semanticObject); 
				return; 
			case CoreDslPackage.CHARACTER_CONSTANT:
				sequence_CharacterConstant(context, (CharacterConstant) semanticObject); 
				return; 
			case CoreDslPackage.COMPOUND_STATEMENT:
				sequence_CompoundStatement(context, (CompoundStatement) semanticObject); 
				return; 
			case CoreDslPackage.CONDITIONAL_EXPRESSION:
				sequence_ConditionalExpression(context, (ConditionalExpression) semanticObject); 
				return; 
			case CoreDslPackage.CORE_DEF:
				sequence_CoreDef(context, (CoreDef) semanticObject); 
				return; 
			case CoreDslPackage.DESCRIPTION_CONTENT:
				sequence_DescriptionContent(context, (DescriptionContent) semanticObject); 
				return; 
			case CoreDslPackage.DESIGNATED_INITIALIZER:
				sequence_DesignatedInitializer(context, (DesignatedInitializer) semanticObject); 
				return; 
			case CoreDslPackage.DESIGNATOR:
				sequence_Designator(context, (Designator) semanticObject); 
				return; 
			case CoreDslPackage.DIRECT_ABSTRACT_DECLARATOR:
				sequence_DirectAbstractDeclarator_ParameterList(context, (DirectAbstractDeclarator) semanticObject); 
				return; 
			case CoreDslPackage.DIRECT_DECLARATOR:
				if (rule == grammarAccess.getDirectDeclaratorRule()
						|| rule == grammarAccess.getVariableRefRule()) {
					sequence_DirectDeclarator(context, (DirectDeclarator) semanticObject); 
					return; 
				}
				else if (action == grammarAccess.getDirectDeclaratorAccess().getDirectDeclaratorLeftAction_2_0()) {
					sequence_DirectDeclarator_DirectDeclarator_2_0(context, (DirectDeclarator) semanticObject); 
					return; 
				}
				else break;
			case CoreDslPackage.ENCODING:
				sequence_Encoding(context, (Encoding) semanticObject); 
				return; 
			case CoreDslPackage.ENUM_SPECIFIER:
				sequence_EnumSpecifier_EnumeratorList(context, (EnumSpecifier) semanticObject); 
				return; 
			case CoreDslPackage.ENUMERATOR:
				sequence_Enumerator(context, (Enumerator) semanticObject); 
				return; 
			case CoreDslPackage.EXPRESSION:
				sequence_Expression(context, (Expression) semanticObject); 
				return; 
			case CoreDslPackage.EXPRESSION_STATEMENT:
				sequence_ExpressionStatement(context, (ExpressionStatement) semanticObject); 
				return; 
			case CoreDslPackage.FLOATING_CONSTANT:
				sequence_FloatingConstant_FloatingSuffix(context, (FloatingConstant) semanticObject); 
				return; 
			case CoreDslPackage.FUNCTION_DEFINITION:
				sequence_FunctionDefinition_ParameterList(context, (FunctionDefinition) semanticObject); 
				return; 
			case CoreDslPackage.IF_STATEMENT:
				sequence_IfStatement(context, (IfStatement) semanticObject); 
				return; 
			case CoreDslPackage.IMPORT:
				sequence_Import(context, (Import) semanticObject); 
				return; 
			case CoreDslPackage.INIT_DECLARATOR:
				sequence_InitDeclarator(context, (InitDeclarator) semanticObject); 
				return; 
			case CoreDslPackage.INITIALIZER:
				sequence_Initializer_InitializerList(context, (Initializer) semanticObject); 
				return; 
			case CoreDslPackage.INSTRUCTION:
				sequence_Instruction(context, (Instruction) semanticObject); 
				return; 
			case CoreDslPackage.INSTRUCTION_SET:
				sequence_InstructionSet(context, (InstructionSet) semanticObject); 
				return; 
			case CoreDslPackage.INTEGER_CONSTANT:
				sequence_IntegerConstant_LongLongSuffix_LongSuffix_UnsignedSuffix(context, (IntegerConstant) semanticObject); 
				return; 
			case CoreDslPackage.ITERATION_STATEMENT:
				sequence_ForCondition_IterationStatement(context, (IterationStatement) semanticObject); 
				return; 
			case CoreDslPackage.JUMP_STATEMENT:
				sequence_JumpStatement(context, (JumpStatement) semanticObject); 
				return; 
			case CoreDslPackage.LABELED_STATEMENT:
				sequence_LabeledStatement(context, (LabeledStatement) semanticObject); 
				return; 
			case CoreDslPackage.LOGICAL_EXPR:
				if (rule == grammarAccess.getConditionalExpressionRule()
						|| action == grammarAccess.getConditionalExpressionAccess().getConditionalExpressionCondAction_1_0()
						|| rule == grammarAccess.getLogicalOrExpressionRule()
						|| rule == grammarAccess.getConstantExpressionRule()) {
					sequence_AndExpression_EqualityExpression_ExclusiveOrExpression_InclusiveOrExpression_LogicalAndExpression_LogicalOrExpression_RelationalExpression(context, (LogicalExpr) semanticObject); 
					return; 
				}
				else if (action == grammarAccess.getLogicalOrExpressionAccess().getLogicalExprLeftAction_1_0()
						|| rule == grammarAccess.getLogicalAndExpressionRule()) {
					sequence_AndExpression_EqualityExpression_ExclusiveOrExpression_InclusiveOrExpression_LogicalAndExpression_RelationalExpression(context, (LogicalExpr) semanticObject); 
					return; 
				}
				else if (action == grammarAccess.getLogicalAndExpressionAccess().getLogicalExprLeftAction_1_0()
						|| rule == grammarAccess.getInclusiveOrExpressionRule()) {
					sequence_AndExpression_EqualityExpression_ExclusiveOrExpression_InclusiveOrExpression_RelationalExpression(context, (LogicalExpr) semanticObject); 
					return; 
				}
				else if (action == grammarAccess.getInclusiveOrExpressionAccess().getLogicalExprLeftAction_1_0()
						|| rule == grammarAccess.getExclusiveOrExpressionRule()) {
					sequence_AndExpression_EqualityExpression_ExclusiveOrExpression_RelationalExpression(context, (LogicalExpr) semanticObject); 
					return; 
				}
				else if (action == grammarAccess.getExclusiveOrExpressionAccess().getLogicalExprLeftAction_1_0()
						|| rule == grammarAccess.getAndExpressionRule()) {
					sequence_AndExpression_EqualityExpression_RelationalExpression(context, (LogicalExpr) semanticObject); 
					return; 
				}
				else if (action == grammarAccess.getAndExpressionAccess().getLogicalExprLeftAction_1_0()
						|| rule == grammarAccess.getEqualityExpressionRule()) {
					sequence_EqualityExpression_RelationalExpression(context, (LogicalExpr) semanticObject); 
					return; 
				}
				else if (action == grammarAccess.getEqualityExpressionAccess().getLogicalExprLeftAction_1_0()
						|| rule == grammarAccess.getRelationalExpressionRule()) {
					sequence_RelationalExpression(context, (LogicalExpr) semanticObject); 
					return; 
				}
				else break;
			case CoreDslPackage.PARAMETER_DECLARATION:
				sequence_ParameterDeclaration(context, (ParameterDeclaration) semanticObject); 
				return; 
			case CoreDslPackage.POD_SPECIFIER:
				sequence_PodSpecifier(context, (PodSpecifier) semanticObject); 
				return; 
			case CoreDslPackage.POSTFIX_EXPRESSION:
				sequence_PostfixExpression(context, (PostfixExpression) semanticObject); 
				return; 
			case CoreDslPackage.POSTFIX_OPERATOR:
				sequence_PostfixOperator(context, (PostfixOperator) semanticObject); 
				return; 
			case CoreDslPackage.PRIMARY_EXPRESSION:
				sequence_PrimaryExpression(context, (PrimaryExpression) semanticObject); 
				return; 
			case CoreDslPackage.RANGE_SPEC:
				sequence_RangeSpec(context, (RangeSpec) semanticObject); 
				return; 
			case CoreDslPackage.STRING_LITERAL:
				sequence_EncodingPrefix_StringLiteral(context, (StringLiteral) semanticObject); 
				return; 
			case CoreDslPackage.STRUCT_DECLARATION:
				sequence_StructDeclaration(context, (StructDeclaration) semanticObject); 
				return; 
			case CoreDslPackage.STRUCT_DECLARATION_SPECIFIER:
				sequence_StructDeclarationSpecifier(context, (StructDeclarationSpecifier) semanticObject); 
				return; 
			case CoreDslPackage.STRUCT_OR_UNION_SPECIFIER:
				sequence_StructOrUnionSpecifier(context, (StructOrUnionSpecifier) semanticObject); 
				return; 
			case CoreDslPackage.SWITCH_STATEMENT:
				sequence_SwitchStatement(context, (SwitchStatement) semanticObject); 
				return; 
			case CoreDslPackage.TYPE_OR_VAR_DECLARATION:
				sequence_AttributeList_DeclarationSpecifier_TypeOrVarDeclaration(context, (TypeOrVarDeclaration) semanticObject); 
				return; 
			case CoreDslPackage.TYPEDEF_DECLARATION:
				sequence_AttributeList_DeclarationSpecifier_TypedefDeclaration(context, (TypedefDeclaration) semanticObject); 
				return; 
			case CoreDslPackage.TYPEDEF_REF:
				sequence_TypedefRef(context, (TypedefRef) semanticObject); 
				return; 
			case CoreDslPackage.UNARY_EXPRESSION:
				sequence_UnaryExpression_UnaryOperator(context, (UnaryExpression) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     ShiftExpression.ArithmeticExpression_1_0 returns ArithmeticExpression
	 *     AdditiveExpression returns ArithmeticExpression
	 *
	 * Constraint:
	 *     (
	 *         (left=AdditiveExpression_ArithmeticExpression_1_0 (op='+' | op='-') right=AdditiveExpression) | 
	 *         (left=MultiplicativeExpression_ArithmeticExpression_1_0 (op='*' | op='/' | op='%') right=MultiplicativeExpression)
	 *     )
	 */
	protected void sequence_AdditiveExpression_MultiplicativeExpression(ISerializationContext context, ArithmeticExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ConditionalExpression returns ArithmeticExpression
	 *     ConditionalExpression.ConditionalExpression_1_0 returns ArithmeticExpression
	 *     LogicalOrExpression returns ArithmeticExpression
	 *     LogicalOrExpression.LogicalExpr_1_0 returns ArithmeticExpression
	 *     LogicalAndExpression returns ArithmeticExpression
	 *     LogicalAndExpression.LogicalExpr_1_0 returns ArithmeticExpression
	 *     InclusiveOrExpression returns ArithmeticExpression
	 *     InclusiveOrExpression.LogicalExpr_1_0 returns ArithmeticExpression
	 *     ExclusiveOrExpression returns ArithmeticExpression
	 *     ExclusiveOrExpression.LogicalExpr_1_0 returns ArithmeticExpression
	 *     AndExpression returns ArithmeticExpression
	 *     AndExpression.LogicalExpr_1_0 returns ArithmeticExpression
	 *     EqualityExpression returns ArithmeticExpression
	 *     EqualityExpression.LogicalExpr_1_0 returns ArithmeticExpression
	 *     RelationalExpression returns ArithmeticExpression
	 *     RelationalExpression.LogicalExpr_1_0 returns ArithmeticExpression
	 *     ShiftExpression returns ArithmeticExpression
	 *     ConstantExpression returns ArithmeticExpression
	 *
	 * Constraint:
	 *     (
	 *         (left=ShiftExpression_ArithmeticExpression_1_0 (op='<<' | op='>>') right=ShiftExpression) | 
	 *         (left=AdditiveExpression_ArithmeticExpression_1_0 (op='+' | op='-') right=AdditiveExpression) | 
	 *         (left=MultiplicativeExpression_ArithmeticExpression_1_0 (op='*' | op='/' | op='%') right=MultiplicativeExpression)
	 *     )
	 */
	protected void sequence_AdditiveExpression_MultiplicativeExpression_ShiftExpression(ISerializationContext context, ArithmeticExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ConditionalExpression returns LogicalExpr
	 *     ConditionalExpression.ConditionalExpression_1_0 returns LogicalExpr
	 *     LogicalOrExpression returns LogicalExpr
	 *     ConstantExpression returns LogicalExpr
	 *
	 * Constraint:
	 *     (
	 *         (left=LogicalOrExpression_LogicalExpr_1_0 op='||' right=LogicalOrExpression) | 
	 *         (left=LogicalAndExpression_LogicalExpr_1_0 op='&&' right=LogicalAndExpression) | 
	 *         (left=InclusiveOrExpression_LogicalExpr_1_0 op='|' right=InclusiveOrExpression) | 
	 *         (left=ExclusiveOrExpression_LogicalExpr_1_0 op='^' right=ExclusiveOrExpression) | 
	 *         (left=AndExpression_LogicalExpr_1_0 op='&' right=AndExpression) | 
	 *         (left=EqualityExpression_LogicalExpr_1_0 (op='==' | op='!=') right=EqualityExpression) | 
	 *         (left=RelationalExpression_LogicalExpr_1_0 (op='<' | op='>' | op='<=' | op='>=') right=RelationalExpression)
	 *     )
	 */
	protected void sequence_AndExpression_EqualityExpression_ExclusiveOrExpression_InclusiveOrExpression_LogicalAndExpression_LogicalOrExpression_RelationalExpression(ISerializationContext context, LogicalExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LogicalOrExpression.LogicalExpr_1_0 returns LogicalExpr
	 *     LogicalAndExpression returns LogicalExpr
	 *
	 * Constraint:
	 *     (
	 *         (left=LogicalAndExpression_LogicalExpr_1_0 op='&&' right=LogicalAndExpression) | 
	 *         (left=InclusiveOrExpression_LogicalExpr_1_0 op='|' right=InclusiveOrExpression) | 
	 *         (left=ExclusiveOrExpression_LogicalExpr_1_0 op='^' right=ExclusiveOrExpression) | 
	 *         (left=AndExpression_LogicalExpr_1_0 op='&' right=AndExpression) | 
	 *         (left=EqualityExpression_LogicalExpr_1_0 (op='==' | op='!=') right=EqualityExpression) | 
	 *         (left=RelationalExpression_LogicalExpr_1_0 (op='<' | op='>' | op='<=' | op='>=') right=RelationalExpression)
	 *     )
	 */
	protected void sequence_AndExpression_EqualityExpression_ExclusiveOrExpression_InclusiveOrExpression_LogicalAndExpression_RelationalExpression(ISerializationContext context, LogicalExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LogicalAndExpression.LogicalExpr_1_0 returns LogicalExpr
	 *     InclusiveOrExpression returns LogicalExpr
	 *
	 * Constraint:
	 *     (
	 *         (left=InclusiveOrExpression_LogicalExpr_1_0 op='|' right=InclusiveOrExpression) | 
	 *         (left=ExclusiveOrExpression_LogicalExpr_1_0 op='^' right=ExclusiveOrExpression) | 
	 *         (left=AndExpression_LogicalExpr_1_0 op='&' right=AndExpression) | 
	 *         (left=EqualityExpression_LogicalExpr_1_0 (op='==' | op='!=') right=EqualityExpression) | 
	 *         (left=RelationalExpression_LogicalExpr_1_0 (op='<' | op='>' | op='<=' | op='>=') right=RelationalExpression)
	 *     )
	 */
	protected void sequence_AndExpression_EqualityExpression_ExclusiveOrExpression_InclusiveOrExpression_RelationalExpression(ISerializationContext context, LogicalExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     InclusiveOrExpression.LogicalExpr_1_0 returns LogicalExpr
	 *     ExclusiveOrExpression returns LogicalExpr
	 *
	 * Constraint:
	 *     (
	 *         (left=ExclusiveOrExpression_LogicalExpr_1_0 op='^' right=ExclusiveOrExpression) | 
	 *         (left=AndExpression_LogicalExpr_1_0 op='&' right=AndExpression) | 
	 *         (left=EqualityExpression_LogicalExpr_1_0 (op='==' | op='!=') right=EqualityExpression) | 
	 *         (left=RelationalExpression_LogicalExpr_1_0 (op='<' | op='>' | op='<=' | op='>=') right=RelationalExpression)
	 *     )
	 */
	protected void sequence_AndExpression_EqualityExpression_ExclusiveOrExpression_RelationalExpression(ISerializationContext context, LogicalExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExclusiveOrExpression.LogicalExpr_1_0 returns LogicalExpr
	 *     AndExpression returns LogicalExpr
	 *
	 * Constraint:
	 *     (
	 *         (left=AndExpression_LogicalExpr_1_0 op='&' right=AndExpression) | 
	 *         (left=EqualityExpression_LogicalExpr_1_0 (op='==' | op='!=') right=EqualityExpression) | 
	 *         (left=RelationalExpression_LogicalExpr_1_0 (op='<' | op='>' | op='<=' | op='>=') right=RelationalExpression)
	 *     )
	 */
	protected void sequence_AndExpression_EqualityExpression_RelationalExpression(ISerializationContext context, LogicalExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns AssignmentExpression
	 *     Expression.Expression_1_0 returns AssignmentExpression
	 *     AssignmentExpression returns AssignmentExpression
	 *
	 * Constraint:
	 *     (
	 *         left=AssignmentExpression_AssignmentExpression_1 
	 *         (
	 *             op='=' | 
	 *             op='*=' | 
	 *             op='/=' | 
	 *             op='%=' | 
	 *             op='+=' | 
	 *             op='-=' | 
	 *             op='<<=' | 
	 *             op='>>=' | 
	 *             op='&=' | 
	 *             op='^=' | 
	 *             op='|='
	 *         ) 
	 *         right=ConditionalExpression
	 *     )
	 */
	protected void sequence_AssignmentExpression(ISerializationContext context, AssignmentExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BlockItem returns TypeOrVarDeclaration
	 *     Declaration returns TypeOrVarDeclaration
	 *     TypeOrVarDeclaration returns TypeOrVarDeclaration
	 *
	 * Constraint:
	 *     (
	 *         ((storage+=StorageClassSpecifier | qualifiers+=TypeQualifier)? (attrs+=Attribute attrs+=Attribute*)?)+ 
	 *         type=TypeSpecifier 
	 *         size=BitSizeSpecifier? 
	 *         (init+=InitDeclarator init+=InitDeclarator*)?
	 *     )
	 */
	protected void sequence_AttributeList_DeclarationSpecifier_TypeOrVarDeclaration(ISerializationContext context, TypeOrVarDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BlockItem returns TypedefDeclaration
	 *     Declaration returns TypedefDeclaration
	 *     TypedefDeclaration returns TypedefDeclaration
	 *
	 * Constraint:
	 *     (((storage+=StorageClassSpecifier | qualifiers+=TypeQualifier)? (attrs+=Attribute attrs+=Attribute*)?)+ type=TypeSpecifier init+=InitDeclarator)
	 */
	protected void sequence_AttributeList_DeclarationSpecifier_TypedefDeclaration(ISerializationContext context, TypedefDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Field returns BitField
	 *     BitField returns BitField
	 *     VariableRef returns BitField
	 *
	 * Constraint:
	 *     (name=ID bitRange=RangeSpec type=BitfieldDataType?)
	 */
	protected void sequence_BitField(ISerializationContext context, BitField semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BitSizeSpecifier returns BitSizeSpecifier
	 *
	 * Constraint:
	 *     (size+=BitSizeValue (size+=BitSizeValue size+=BitSizeValue size+=BitSizeValue)?)
	 */
	protected void sequence_BitSizeSpecifier(ISerializationContext context, BitSizeSpecifier semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BitSizeValue returns BitSizeValue
	 *
	 * Constraint:
	 *     (val+=NATURAL | constant+=[Constant|ID])
	 */
	protected void sequence_BitSizeValue(ISerializationContext context, BitSizeValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Field returns BitValue
	 *     BitValue returns BitValue
	 *     VariableRef returns BitValue
	 *
	 * Constraint:
	 *     name=BVAL
	 */
	protected void sequence_BitValue(ISerializationContext context, BitValue semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CoreDslPackage.Literals.VARIABLE_REF__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CoreDslPackage.Literals.VARIABLE_REF__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBitValueAccess().getNameBVALTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Constant returns BoolConstant
	 *     BoolConstant returns BoolConstant
	 *
	 * Constraint:
	 *     val=BOOLEAN
	 */
	protected void sequence_BoolConstant(ISerializationContext context, BoolConstant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CoreDslPackage.Literals.BOOL_CONSTANT__VAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CoreDslPackage.Literals.BOOL_CONSTANT__VAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBoolConstantAccess().getValBOOLEANTerminalRuleCall_0(), semanticObject.isVal());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ConditionalExpression returns CastExpression
	 *     ConditionalExpression.ConditionalExpression_1_0 returns CastExpression
	 *     LogicalOrExpression returns CastExpression
	 *     LogicalOrExpression.LogicalExpr_1_0 returns CastExpression
	 *     LogicalAndExpression returns CastExpression
	 *     LogicalAndExpression.LogicalExpr_1_0 returns CastExpression
	 *     InclusiveOrExpression returns CastExpression
	 *     InclusiveOrExpression.LogicalExpr_1_0 returns CastExpression
	 *     ExclusiveOrExpression returns CastExpression
	 *     ExclusiveOrExpression.LogicalExpr_1_0 returns CastExpression
	 *     AndExpression returns CastExpression
	 *     AndExpression.LogicalExpr_1_0 returns CastExpression
	 *     EqualityExpression returns CastExpression
	 *     EqualityExpression.LogicalExpr_1_0 returns CastExpression
	 *     RelationalExpression returns CastExpression
	 *     RelationalExpression.LogicalExpr_1_0 returns CastExpression
	 *     ShiftExpression returns CastExpression
	 *     ShiftExpression.ArithmeticExpression_1_0 returns CastExpression
	 *     AdditiveExpression returns CastExpression
	 *     AdditiveExpression.ArithmeticExpression_1_0 returns CastExpression
	 *     MultiplicativeExpression returns CastExpression
	 *     MultiplicativeExpression.ArithmeticExpression_1_0 returns CastExpression
	 *     CastExpression returns CastExpression
	 *     ConstantExpression returns CastExpression
	 *
	 * Constraint:
	 *     (type=DataTypeSpecifier left=CastExpression)
	 */
	protected void sequence_CastExpression(ISerializationContext context, CastExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CoreDslPackage.Literals.CAST_EXPRESSION__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CoreDslPackage.Literals.CAST_EXPRESSION__TYPE));
			if (transientValues.isValueTransient(semanticObject, CoreDslPackage.Literals.EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CoreDslPackage.Literals.EXPRESSION__LEFT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCastExpressionAccess().getTypeDataTypeSpecifierParserRuleCall_1_1_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getCastExpressionAccess().getLeftCastExpressionParserRuleCall_1_3_0(), semanticObject.getLeft());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Constant returns CharacterConstant
	 *     CharacterConstant returns CharacterConstant
	 *
	 * Constraint:
	 *     (val=CHARCONST | (enc='L' val=CHARCONST) | (enc='u' val=CHARCONST) | (enc='U' val=CHARCONST))
	 */
	protected void sequence_CharacterConstant(ISerializationContext context, CharacterConstant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns CompoundStatement
	 *     CompoundStatement returns CompoundStatement
	 *     BlockItem returns CompoundStatement
	 *
	 * Constraint:
	 *     items+=BlockItem*
	 */
	protected void sequence_CompoundStatement(ISerializationContext context, CompoundStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ConditionalExpression returns ConditionalExpression
	 *     ConstantExpression returns ConditionalExpression
	 *
	 * Constraint:
	 *     (cond=ConditionalExpression_ConditionalExpression_1_0 left=ConditionalExpression right=ConditionalExpression)
	 */
	protected void sequence_ConditionalExpression(ISerializationContext context, ConditionalExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CoreDslPackage.Literals.CONDITIONAL_EXPRESSION__COND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CoreDslPackage.Literals.CONDITIONAL_EXPRESSION__COND));
			if (transientValues.isValueTransient(semanticObject, CoreDslPackage.Literals.EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CoreDslPackage.Literals.EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, CoreDslPackage.Literals.EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CoreDslPackage.Literals.EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConditionalExpressionAccess().getConditionalExpressionCondAction_1_0(), semanticObject.getCond());
		feeder.accept(grammarAccess.getConditionalExpressionAccess().getLeftConditionalExpressionParserRuleCall_1_2_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getConditionalExpressionAccess().getRightConditionalExpressionParserRuleCall_1_4_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ISA returns CoreDef
	 *     CoreDef returns CoreDef
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         (contributingType+=[InstructionSet|ID] contributingType+=[InstructionSet|ID]*)? 
	 *         constants+=Declaration* 
	 *         spaces+=Declaration* 
	 *         regs+=Declaration* 
	 *         instr+=Instruction*
	 *     )
	 */
	protected void sequence_CoreDef(ISerializationContext context, CoreDef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DescriptionContent returns DescriptionContent
	 *
	 * Constraint:
	 *     (imports+=Import* definitions+=ISA+)
	 */
	protected void sequence_DescriptionContent(ISerializationContext context, DescriptionContent semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DesignatedInitializer returns DesignatedInitializer
	 *
	 * Constraint:
	 *     (designators+=Designator+ init=Initializer)
	 */
	protected void sequence_DesignatedInitializer(ISerializationContext context, DesignatedInitializer semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Designator returns Designator
	 *
	 * Constraint:
	 *     (idx=ConstantExpression | prop=ID)
	 */
	protected void sequence_Designator(ISerializationContext context, Designator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AbstractDeclarator returns DirectAbstractDeclarator
	 *     DirectAbstractDeclarator returns DirectAbstractDeclarator
	 *
	 * Constraint:
	 *     ((params+=ParameterDeclaration parameters+=ParameterDeclaration*) | declarator=AbstractDeclarator | expr=ConstantExpression)?
	 */
	protected void sequence_DirectAbstractDeclarator_ParameterList(ISerializationContext context, DirectAbstractDeclarator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DirectDeclarator returns DirectDeclarator
	 *     VariableRef returns DirectDeclarator
	 *
	 * Constraint:
	 *     ((name=ID index=IntegerConstant?) | (left=DirectDeclarator_DirectDeclarator_2_0 qualifiers+=TypeQualifier? expr=ConditionalExpression?))
	 */
	protected void sequence_DirectDeclarator(ISerializationContext context, DirectDeclarator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DirectDeclarator.DirectDeclarator_2_0 returns DirectDeclarator
	 *
	 * Constraint:
	 *     (name=ID index=IntegerConstant?)
	 */
	protected void sequence_DirectDeclarator_DirectDeclarator_2_0(ISerializationContext context, DirectDeclarator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     StringLiteral returns StringLiteral
	 *
	 * Constraint:
	 *     ((prefix='u8' | prefix='u' | prefix='U' | prefix='L')? val=STRING)
	 */
	protected void sequence_EncodingPrefix_StringLiteral(ISerializationContext context, StringLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Encoding returns Encoding
	 *
	 * Constraint:
	 *     (fields+=Field fields+=Field*)
	 */
	protected void sequence_Encoding(ISerializationContext context, Encoding semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TypeSpecifier returns EnumSpecifier
	 *     DataTypeSpecifier returns EnumSpecifier
	 *     EnumSpecifier returns EnumSpecifier
	 *
	 * Constraint:
	 *     ((name=ID? enumerators+=Enumerator enumerators+=Enumerator*) | name=ID)
	 */
	protected void sequence_EnumSpecifier_EnumeratorList(ISerializationContext context, EnumSpecifier semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Enumerator returns Enumerator
	 *
	 * Constraint:
	 *     (name=ID | (name=ID expression=ConstantExpression))
	 */
	protected void sequence_Enumerator(ISerializationContext context, Enumerator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AndExpression.LogicalExpr_1_0 returns LogicalExpr
	 *     EqualityExpression returns LogicalExpr
	 *
	 * Constraint:
	 *     (
	 *         (left=EqualityExpression_LogicalExpr_1_0 (op='==' | op='!=') right=EqualityExpression) | 
	 *         (left=RelationalExpression_LogicalExpr_1_0 (op='<' | op='>' | op='<=' | op='>=') right=RelationalExpression)
	 *     )
	 */
	protected void sequence_EqualityExpression_RelationalExpression(ISerializationContext context, LogicalExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns ExpressionStatement
	 *     BlockItem returns ExpressionStatement
	 *     ExpressionStatement returns ExpressionStatement
	 *
	 * Constraint:
	 *     expr=AssignmentExpression?
	 */
	protected void sequence_ExpressionStatement(ISerializationContext context, ExpressionStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Expression
	 *
	 * Constraint:
	 *     (left=Expression_Expression_1_0 right=AssignmentExpression)
	 */
	protected void sequence_Expression(ISerializationContext context, Expression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CoreDslPackage.Literals.EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CoreDslPackage.Literals.EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, CoreDslPackage.Literals.EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CoreDslPackage.Literals.EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpressionAccess().getExpressionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getExpressionAccess().getRightAssignmentExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Constant returns FloatingConstant
	 *     FloatingConstant returns FloatingConstant
	 *
	 * Constraint:
	 *     (val=FLOAT (f?='f' | l?='l' | f?='F' | f?='L')?)
	 */
	protected void sequence_FloatingConstant_FloatingSuffix(ISerializationContext context, FloatingConstant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns IterationStatement
	 *     BlockItem returns IterationStatement
	 *     IterationStatement returns IterationStatement
	 *
	 * Constraint:
	 *     (
	 *         (type='while' cond=ConditionalExpression stmt=Statement) | 
	 *         (type='do' stmt=Statement cond=ConditionalExpression) | 
	 *         (
	 *             type='for' 
	 *             (startDecl=Declaration | startExpr=Expression)? 
	 *             endExpr=ConditionalExpression? 
	 *             (loopExprs+=AssignmentExpression loopExprs+=AssignmentExpression*)? 
	 *             stmt=Statement
	 *         )
	 *     )
	 */
	protected void sequence_ForCondition_IterationStatement(ISerializationContext context, IterationStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FunctionDefinition returns FunctionDefinition
	 *     VariableRef returns FunctionDefinition
	 *
	 * Constraint:
	 *     (
	 *         extern?='extern'? 
	 *         type=TypeSpecifier 
	 *         name=ID 
	 *         params+=ParameterDeclaration 
	 *         parameters+=ParameterDeclaration* 
	 *         statement=CompoundStatement
	 *     )
	 */
	protected void sequence_FunctionDefinition_ParameterList(ISerializationContext context, FunctionDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns IfStatement
	 *     BlockItem returns IfStatement
	 *     SelectionStatement returns IfStatement
	 *     IfStatement returns IfStatement
	 *
	 * Constraint:
	 *     (cond=ConditionalExpression thenStmt=Statement elseStmt=Statement?)
	 */
	protected void sequence_IfStatement(ISerializationContext context, IfStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Import returns Import
	 *
	 * Constraint:
	 *     importURI=STRING
	 */
	protected void sequence_Import(ISerializationContext context, Import semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CoreDslPackage.Literals.IMPORT__IMPORT_URI) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CoreDslPackage.Literals.IMPORT__IMPORT_URI));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getImportAccess().getImportURISTRINGTerminalRuleCall_1_0(), semanticObject.getImportURI());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     InitDeclarator returns InitDeclarator
	 *
	 * Constraint:
	 *     (declarator=DirectDeclarator initializer=Initializer?)
	 */
	protected void sequence_InitDeclarator(ISerializationContext context, InitDeclarator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Initializer returns Initializer
	 *
	 * Constraint:
	 *     (((init+=DesignatedInitializer | init+=Initializer) (init+=DesignatedInitializer | init+=Initializer)?) | expr=ConditionalExpression)
	 */
	protected void sequence_Initializer_InitializerList(ISerializationContext context, Initializer semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ISA returns InstructionSet
	 *     InstructionSet returns InstructionSet
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         superType=[InstructionSet|ID]? 
	 *         constants+=Declaration* 
	 *         spaces+=Declaration* 
	 *         regs+=Declaration* 
	 *         func+=FunctionDefinition* 
	 *         instr+=Instruction+
	 *     )
	 */
	protected void sequence_InstructionSet(ISerializationContext context, InstructionSet semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Instruction returns Instruction
	 *
	 * Constraint:
	 *     (name=ID (attributes+=InstrAttribute attributes+=InstrAttribute*)? encoding=Encoding disass=STRING? behavior=CompoundStatement)
	 */
	protected void sequence_Instruction(ISerializationContext context, Instruction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Constant returns IntegerConstant
	 *     IntegerConstant returns IntegerConstant
	 *
	 * Constraint:
	 *     (
	 *         val=NATURAL 
	 *         (unsigned?='u' | unsigned?='U')? 
	 *         (
	 *             (long?='l' | long?='L' | longlong?='ll' | longlong?='LL') 
	 *             ((unsigned?='u' | unsigned?='U')? (long?='l' | long?='L' | longlong?='ll' | longlong?='LL'))* 
	 *             (unsigned?='u' | unsigned?='U')?
	 *         )?
	 *     )
	 */
	protected void sequence_IntegerConstant_LongLongSuffix_LongSuffix_UnsignedSuffix(ISerializationContext context, IntegerConstant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns JumpStatement
	 *     BlockItem returns JumpStatement
	 *     JumpStatement returns JumpStatement
	 *
	 * Constraint:
	 *     (type='continue' | type='break' | (type='return' expr=ConditionalExpression?))
	 */
	protected void sequence_JumpStatement(ISerializationContext context, JumpStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LabeledStatement returns LabeledStatement
	 *
	 * Constraint:
	 *     ((constExpr=ConstantExpression stmt=Statement) | stmt=Statement)
	 */
	protected void sequence_LabeledStatement(ISerializationContext context, LabeledStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AdditiveExpression.ArithmeticExpression_1_0 returns ArithmeticExpression
	 *     MultiplicativeExpression returns ArithmeticExpression
	 *
	 * Constraint:
	 *     (left=MultiplicativeExpression_ArithmeticExpression_1_0 (op='*' | op='/' | op='%') right=MultiplicativeExpression)
	 */
	protected void sequence_MultiplicativeExpression(ISerializationContext context, ArithmeticExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ParameterDeclaration returns ParameterDeclaration
	 *
	 * Constraint:
	 *     (type=TypeSpecifier (declarator=DirectDeclarator | declarator=AbstractDeclarator)?)
	 */
	protected void sequence_ParameterDeclaration(ISerializationContext context, ParameterDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TypeSpecifier returns PodSpecifier
	 *     DataTypeSpecifier returns PodSpecifier
	 *     PodSpecifier returns PodSpecifier
	 *
	 * Constraint:
	 *     dataType+=DataTypes+
	 */
	protected void sequence_PodSpecifier(ISerializationContext context, PodSpecifier semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AssignmentExpression.AssignmentExpression_1 returns PostfixExpression
	 *     ConditionalExpression returns PostfixExpression
	 *     ConditionalExpression.ConditionalExpression_1_0 returns PostfixExpression
	 *     LogicalOrExpression returns PostfixExpression
	 *     LogicalOrExpression.LogicalExpr_1_0 returns PostfixExpression
	 *     LogicalAndExpression returns PostfixExpression
	 *     LogicalAndExpression.LogicalExpr_1_0 returns PostfixExpression
	 *     InclusiveOrExpression returns PostfixExpression
	 *     InclusiveOrExpression.LogicalExpr_1_0 returns PostfixExpression
	 *     ExclusiveOrExpression returns PostfixExpression
	 *     ExclusiveOrExpression.LogicalExpr_1_0 returns PostfixExpression
	 *     AndExpression returns PostfixExpression
	 *     AndExpression.LogicalExpr_1_0 returns PostfixExpression
	 *     EqualityExpression returns PostfixExpression
	 *     EqualityExpression.LogicalExpr_1_0 returns PostfixExpression
	 *     RelationalExpression returns PostfixExpression
	 *     RelationalExpression.LogicalExpr_1_0 returns PostfixExpression
	 *     ShiftExpression returns PostfixExpression
	 *     ShiftExpression.ArithmeticExpression_1_0 returns PostfixExpression
	 *     AdditiveExpression returns PostfixExpression
	 *     AdditiveExpression.ArithmeticExpression_1_0 returns PostfixExpression
	 *     MultiplicativeExpression returns PostfixExpression
	 *     MultiplicativeExpression.ArithmeticExpression_1_0 returns PostfixExpression
	 *     CastExpression returns PostfixExpression
	 *     UnaryExpression returns PostfixExpression
	 *     PostfixExpression returns PostfixExpression
	 *     PostfixExpression.PostfixExpression_1_0 returns PostfixExpression
	 *     ConstantExpression returns PostfixExpression
	 *
	 * Constraint:
	 *     (left=PostfixExpression_PostfixExpression_1_0 ops+=PostfixOperator)
	 */
	protected void sequence_PostfixExpression(ISerializationContext context, PostfixExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PostfixOperator returns PostfixOperator
	 *
	 * Constraint:
	 *     (
	 *         (op='[' args+=ConditionalExpression args+=ConditionalExpression?) | 
	 *         (op='(' (args+=ConditionalExpression args+=ConditionalExpression*)?) | 
	 *         (op='.' member=[DirectDeclarator|ID]) | 
	 *         (op='->' member=[DirectDeclarator|ID]) | 
	 *         op='++' | 
	 *         op='--'
	 *     )
	 */
	protected void sequence_PostfixOperator(ISerializationContext context, PostfixOperator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AssignmentExpression.AssignmentExpression_1 returns PrimaryExpression
	 *     ConditionalExpression returns PrimaryExpression
	 *     ConditionalExpression.ConditionalExpression_1_0 returns PrimaryExpression
	 *     LogicalOrExpression returns PrimaryExpression
	 *     LogicalOrExpression.LogicalExpr_1_0 returns PrimaryExpression
	 *     LogicalAndExpression returns PrimaryExpression
	 *     LogicalAndExpression.LogicalExpr_1_0 returns PrimaryExpression
	 *     InclusiveOrExpression returns PrimaryExpression
	 *     InclusiveOrExpression.LogicalExpr_1_0 returns PrimaryExpression
	 *     ExclusiveOrExpression returns PrimaryExpression
	 *     ExclusiveOrExpression.LogicalExpr_1_0 returns PrimaryExpression
	 *     AndExpression returns PrimaryExpression
	 *     AndExpression.LogicalExpr_1_0 returns PrimaryExpression
	 *     EqualityExpression returns PrimaryExpression
	 *     EqualityExpression.LogicalExpr_1_0 returns PrimaryExpression
	 *     RelationalExpression returns PrimaryExpression
	 *     RelationalExpression.LogicalExpr_1_0 returns PrimaryExpression
	 *     ShiftExpression returns PrimaryExpression
	 *     ShiftExpression.ArithmeticExpression_1_0 returns PrimaryExpression
	 *     AdditiveExpression returns PrimaryExpression
	 *     AdditiveExpression.ArithmeticExpression_1_0 returns PrimaryExpression
	 *     MultiplicativeExpression returns PrimaryExpression
	 *     MultiplicativeExpression.ArithmeticExpression_1_0 returns PrimaryExpression
	 *     CastExpression returns PrimaryExpression
	 *     UnaryExpression returns PrimaryExpression
	 *     PostfixExpression returns PrimaryExpression
	 *     PostfixExpression.PostfixExpression_1_0 returns PrimaryExpression
	 *     PrimaryExpression returns PrimaryExpression
	 *     ConstantExpression returns PrimaryExpression
	 *
	 * Constraint:
	 *     (ref=[VariableRef|ID] | constant=Constant | literal+=StringLiteral+ | left=ConditionalExpression)
	 */
	protected void sequence_PrimaryExpression(ISerializationContext context, PrimaryExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RangeSpec returns RangeSpec
	 *
	 * Constraint:
	 *     (left=NATURAL right=NATURAL)
	 */
	protected void sequence_RangeSpec(ISerializationContext context, RangeSpec semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CoreDslPackage.Literals.RANGE_SPEC__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CoreDslPackage.Literals.RANGE_SPEC__LEFT));
			if (transientValues.isValueTransient(semanticObject, CoreDslPackage.Literals.RANGE_SPEC__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CoreDslPackage.Literals.RANGE_SPEC__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRangeSpecAccess().getLeftNATURALTerminalRuleCall_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getRangeSpecAccess().getRightNATURALTerminalRuleCall_3_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     EqualityExpression.LogicalExpr_1_0 returns LogicalExpr
	 *     RelationalExpression returns LogicalExpr
	 *
	 * Constraint:
	 *     (left=RelationalExpression_LogicalExpr_1_0 (op='<' | op='>' | op='<=' | op='>=') right=RelationalExpression)
	 */
	protected void sequence_RelationalExpression(ISerializationContext context, LogicalExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     StructDeclarationSpecifier returns StructDeclarationSpecifier
	 *
	 * Constraint:
	 *     (type=TypeSpecifier | qualifiers+=TypeQualifier)
	 */
	protected void sequence_StructDeclarationSpecifier(ISerializationContext context, StructDeclarationSpecifier semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     StructDeclaration returns StructDeclaration
	 *
	 * Constraint:
	 *     (specifier=StructDeclarationSpecifier decls+=DirectDeclarator decls+=DirectDeclarator*)
	 */
	protected void sequence_StructDeclaration(ISerializationContext context, StructDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TypeSpecifier returns StructOrUnionSpecifier
	 *     DataTypeSpecifier returns StructOrUnionSpecifier
	 *     StructOrUnionSpecifier returns StructOrUnionSpecifier
	 *
	 * Constraint:
	 *     ((composeType=StructOrUnion name=ID? decls+=StructDeclaration*) | (composeType=StructOrUnion name=ID))
	 */
	protected void sequence_StructOrUnionSpecifier(ISerializationContext context, StructOrUnionSpecifier semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns SwitchStatement
	 *     BlockItem returns SwitchStatement
	 *     SelectionStatement returns SwitchStatement
	 *     SwitchStatement returns SwitchStatement
	 *
	 * Constraint:
	 *     (cond=ConditionalExpression items+=LabeledStatement)
	 */
	protected void sequence_SwitchStatement(ISerializationContext context, SwitchStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TypeSpecifier returns TypedefRef
	 *     TypedefRef returns TypedefRef
	 *
	 * Constraint:
	 *     ref=[DirectDeclarator|ID]
	 */
	protected void sequence_TypedefRef(ISerializationContext context, TypedefRef semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CoreDslPackage.Literals.TYPEDEF_REF__REF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CoreDslPackage.Literals.TYPEDEF_REF__REF));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTypedefRefAccess().getRefDirectDeclaratorIDTerminalRuleCall_0_1(), semanticObject.eGet(CoreDslPackage.Literals.TYPEDEF_REF__REF, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AssignmentExpression.AssignmentExpression_1 returns UnaryExpression
	 *     ConditionalExpression returns UnaryExpression
	 *     ConditionalExpression.ConditionalExpression_1_0 returns UnaryExpression
	 *     LogicalOrExpression returns UnaryExpression
	 *     LogicalOrExpression.LogicalExpr_1_0 returns UnaryExpression
	 *     LogicalAndExpression returns UnaryExpression
	 *     LogicalAndExpression.LogicalExpr_1_0 returns UnaryExpression
	 *     InclusiveOrExpression returns UnaryExpression
	 *     InclusiveOrExpression.LogicalExpr_1_0 returns UnaryExpression
	 *     ExclusiveOrExpression returns UnaryExpression
	 *     ExclusiveOrExpression.LogicalExpr_1_0 returns UnaryExpression
	 *     AndExpression returns UnaryExpression
	 *     AndExpression.LogicalExpr_1_0 returns UnaryExpression
	 *     EqualityExpression returns UnaryExpression
	 *     EqualityExpression.LogicalExpr_1_0 returns UnaryExpression
	 *     RelationalExpression returns UnaryExpression
	 *     RelationalExpression.LogicalExpr_1_0 returns UnaryExpression
	 *     ShiftExpression returns UnaryExpression
	 *     ShiftExpression.ArithmeticExpression_1_0 returns UnaryExpression
	 *     AdditiveExpression returns UnaryExpression
	 *     AdditiveExpression.ArithmeticExpression_1_0 returns UnaryExpression
	 *     MultiplicativeExpression returns UnaryExpression
	 *     MultiplicativeExpression.ArithmeticExpression_1_0 returns UnaryExpression
	 *     CastExpression returns UnaryExpression
	 *     UnaryExpression returns UnaryExpression
	 *     ConstantExpression returns UnaryExpression
	 *
	 * Constraint:
	 *     (
	 *         (op='++' left=UnaryExpression) | 
	 *         (op='--' left=UnaryExpression) | 
	 *         (op='sizeof' (left=PostfixExpression | type=DataTypeSpecifier)) | 
	 *         (
	 *             (
	 *                 op='&' | 
	 *                 op='*' | 
	 *                 op='+' | 
	 *                 op='-' | 
	 *                 op='~' | 
	 *                 op='!'
	 *             ) 
	 *             left=CastExpression
	 *         )
	 *     )
	 */
	protected void sequence_UnaryExpression_UnaryOperator(ISerializationContext context, UnaryExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
